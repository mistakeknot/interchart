<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Interverse Ecosystem</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #0d1117;
  color: #c9d1d9;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
}

#toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
  background: #161b22;
  border-bottom: 1px solid #30363d;
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  height: 44px;
}

#toolbar .title {
  font-weight: 600;
  font-size: 14px;
  color: #f0f6fc;
  white-space: nowrap;
}

#toolbar .stats {
  font-size: 11px;
  color: #8b949e;
  white-space: nowrap;
}

#filter-sidebar {
  position: fixed;
  top: 44px;
  left: 0;
  width: 240px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-right: 1px solid #30363d;
  z-index: 90;
  overflow-y: auto;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  transition: transform 0.25s ease, opacity 0.25s ease;
}
#filter-sidebar.collapsed {
  transform: translateX(-240px);
  opacity: 0;
  pointer-events: none;
}

#filter-sidebar .sidebar-title {
  font-size: 11px;
  font-weight: 600;
  color: #8b949e;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 4px;
}

#filter-sidebar .meta-row {
  display: flex;
  gap: 4px;
  margin-bottom: 8px;
}

#filter-list, #domain-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  border-top: 1px solid #30363d;
  padding-top: 8px;
}

.filter-btn {
  border: 1px solid #30363d;
  background: transparent;
  color: #8b949e;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
  width: 100%;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 6px;
}

.filter-btn .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}

.filter-btn.active {
  border-color: var(--type-color);
  color: var(--type-color);
  background: color-mix(in srgb, var(--type-color) 12%, transparent);
}

.filter-btn:hover { border-color: #58a6ff; }

.filter-btn.meta {
  font-weight: 600;
  border-color: #58a6ff;
  color: #58a6ff;
  width: 100%;
  flex: 0 0 auto;
  text-align: left;
  justify-content: flex-start;
  padding: 3px 8px;
  font-size: 10px;
}

#filter-sidebar .meta-row .filter-btn.meta {
  width: auto;
  flex: 1;
  text-align: center;
  justify-content: center;
  font-size: 11px;
  padding: 4px 10px;
}

.filter-btn.meta:hover { background: rgba(88, 166, 255, 0.1); }

#sidebar-toggle {
  background: none; border: 1px solid #30363d; color: #8b949e;
  width: 28px; height: 28px; border-radius: 6px; cursor: pointer;
  font-size: 14px; display: flex; align-items: center; justify-content: center;
  transition: all 0.15s; flex-shrink: 0;
}
#sidebar-toggle:hover { border-color: #58a6ff; color: #58a6ff; }

#search-box {
  border: 1px solid #30363d; background: #0d1117; color: #c9d1d9;
  padding: 4px 10px; border-radius: 6px; font-size: 12px;
  width: 160px; margin-left: auto;
}
#search-box:focus { outline: none; border-color: #58a6ff; }

#graph { width: 100vw; height: 100vh; padding-top: 44px; }
#graph svg { width: 100%; height: 100%; }

.node circle { cursor: pointer; transition: opacity 0.2s; }
.node circle:hover { filter: brightness(1.3); }
.node text { font-size: 10px; fill: #8b949e; pointer-events: none; user-select: none; }

.link { stroke-opacity: 0.3; transition: stroke-opacity 0.2s; }
.link.provides-skill { stroke: #50C878; }
.link.provides-agent { stroke: #FF8C42; }
.link.provides-mcp { stroke: #9B59B6; stroke-dasharray: 4 2; }
.link.fires-hook { stroke: #E74C3C; stroke-dasharray: 2 2; }
.link.companion-of { stroke: #F39C12; stroke-dasharray: 6 3; stroke-width: 2; }
.link.depends-on { stroke: #1ABC9C; stroke-dasharray: 4 4; }
.link.part-of { stroke: #30363d; }

.domain-hull {
  fill-opacity: 0.08;
  stroke-opacity: 0.35;
  stroke-width: 1.5;
  stroke-dasharray: 6 3;
  pointer-events: none;
  transition: fill-opacity 0.3s, stroke-opacity 0.3s;
}
.domain-hull:hover { fill-opacity: 0.14; stroke-opacity: 0.5; }
.domain-hull.hidden { fill-opacity: 0; stroke-opacity: 0; }

.domain-label {
  font-size: 9px;
  font-weight: 600;
  fill-opacity: 0.4;
  pointer-events: none;
  text-anchor: middle;
}

.dimmed circle { opacity: 0.1; }
.dimmed text { opacity: 0.1; }
.link.dimmed { stroke-opacity: 0.03; }

.highlighted circle { filter: brightness(1.4) drop-shadow(0 0 6px var(--glow)); }
.highlighted text { fill: #f0f6fc; font-weight: 600; }
.link.highlighted { stroke-opacity: 0.8; stroke-width: 2; }

#detail-panel {
  position: fixed;
  top: 44px;
  right: -360px;
  width: 340px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-left: 1px solid #30363d;
  z-index: 90;
  transition: right 0.25s ease;
  overflow-y: auto;
  padding: 20px;
}

#detail-panel.open { right: 0; }

#detail-panel .close-btn {
  position: absolute; top: 12px; right: 12px;
  background: none; border: none; color: #8b949e; cursor: pointer; font-size: 18px;
}
#detail-panel .close-btn:hover { color: #f0f6fc; }

#detail-panel h2 { font-size: 18px; color: #f0f6fc; margin-bottom: 4px; padding-right: 24px; }

#detail-panel .type-badge {
  display: inline-block; padding: 2px 8px; border-radius: 10px;
  font-size: 11px; font-weight: 600; margin-bottom: 12px;
}

#detail-panel .description { font-size: 13px; color: #8b949e; line-height: 1.5; margin-bottom: 16px; }

#detail-panel .section-title {
  font-size: 12px; font-weight: 600; color: #58a6ff;
  text-transform: uppercase; letter-spacing: 0.5px;
  margin-top: 16px; margin-bottom: 8px;
}

#detail-panel .child-list { list-style: none; padding: 0; }
#detail-panel .child-list li {
  font-size: 12px; color: #c9d1d9; padding: 3px 0 3px 8px; cursor: pointer;
}
#detail-panel .child-list li:hover { color: #58a6ff; }
#detail-panel .child-list a { color: #58a6ff; text-decoration: none; }
#detail-panel .child-list a:hover { text-decoration: underline; }
#detail-panel .child-type { font-size: 10px; color: #8b949e; margin-left: 4px; }

#detail-panel .meta-item { font-size: 12px; color: #8b949e; margin-bottom: 4px; }
#detail-panel .meta-item span { color: #c9d1d9; }

/* Tab bar */
#tab-bar {
  display: flex;
  gap: 4px;
  margin-left: 8px;
}

.tab-btn {
  background: transparent;
  border: 1px solid #30363d;
  color: #8b949e;
  padding: 3px 12px;
  border-radius: 14px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}
.tab-btn:hover { border-color: #58a6ff; color: #c9d1d9; }
.tab-btn.active {
  background: rgba(88, 166, 255, 0.15);
  border-color: #58a6ff;
  color: #58a6ff;
}

/* Tab content */
.tab-content { display: none; }
.tab-content.active { display: block; }

/* Sprint container */
#sprint-container {
  width: 100vw;
  height: calc(100vh - 44px);
  margin-top: 44px;
  background: #0d1117;
  overflow: hidden;
}
#sprint-container svg { width: 100%; height: 100%; }

.sprint-node rect {
  cursor: pointer;
  transition: filter 0.15s;
}
.sprint-node rect:hover { filter: brightness(1.3); }
.sprint-node text { pointer-events: none; user-select: none; }

.sprint-node.selected rect {
  filter: brightness(1.4) drop-shadow(0 0 8px rgba(88, 166, 255, 0.6));
}

.gate-diamond { pointer-events: none; }

</style>
</head>
<body>

<div id="toolbar">
  <button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle filters">&#9776;</button>
  <span class="title">Interverse</span>
  <div id="tab-bar">
    <button class="tab-btn active" data-tab="ecosystem" onclick="switchTab('ecosystem')">Ecosystem</button>
    <button class="tab-btn" data-tab="sprint" onclick="switchTab('sprint')">Sprint Workflow</button>
  </div>
  <span class="stats" id="stats"></span>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>

<div id="tab-ecosystem" class="tab-content active">
  <div id="filter-sidebar" class="collapsed">
    <div class="sidebar-title">Filters</div>
    <div class="meta-row">
      <button class="filter-btn meta" onclick="showAll()">All</button>
      <button class="filter-btn meta" onclick="hideAll()">None</button>
    </div>
    <div id="filter-list"></div>
    <div class="sidebar-title" style="margin-top: 12px">Domains</div>
    <div class="meta-row">
      <button class="filter-btn meta" onclick="showAllDomains()">All</button>
      <button class="filter-btn meta" onclick="hideAllDomains()">None</button>
    </div>
    <div id="domain-list"></div>
  </div>

  <div id="graph"></div>
</div>

<div id="tab-sprint" class="tab-content">
  <div id="sprint-container"></div>
</div>

<div id="detail-panel">
  <button class="close-btn" onclick="closePanel()">&times;</button>
  <div id="panel-content"></div>
</div>


<script>
// DATA_PLACEHOLDER is replaced by the generator with scanned JSON
const data = /*DATA_PLACEHOLDER*/;

const TYPE_COLORS = {
  'plugin': '#4A90D9', 'skill': '#50C878', 'agent': '#FF8C42',
  'mcp-server': '#9B59B6', 'hook-event': '#E74C3C', 'hub': '#F39C12',
  'kernel': '#1ABC9C', 'service': '#E74C3C', 'sdk': '#95A5A6',
  'tui': '#E91E63', 'monorepo': '#58a6ff'
};

const TYPE_SIZES = {
  'monorepo': 24, 'hub': 20, 'kernel': 16, 'service': 14, 'tui': 14,
  'sdk': 12, 'plugin': 12, 'skill': 6, 'agent': 6, 'mcp-server': 7, 'hook-event': 7
};

const TYPE_LABELS = {
  'plugin': 'Plugin', 'skill': 'Skill', 'agent': 'Agent', 'mcp-server': 'MCP Server',
  'hook-event': 'Hook Event', 'hub': 'Hub', 'kernel': 'Kernel', 'service': 'Service',
  'sdk': 'SDK', 'tui': 'TUI', 'monorepo': 'Monorepo'
};

// State
const activeFilters = new Set(Object.keys(TYPE_COLORS));
let selectedNode = null;
let searchQuery = '';

// Stats (updated after domain extraction below)

// Build filter buttons into sidebar
const filterList = document.getElementById('filter-list');
for (const [type, color] of Object.entries(TYPE_COLORS)) {
  const count = data.stats.byType[type] || 0;
  if (count === 0) continue;
  const btn = document.createElement('button');
  btn.className = 'filter-btn active';
  btn.style.setProperty('--type-color', color);
  const dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  btn.appendChild(document.createTextNode(TYPE_LABELS[type] + ' (' + count + ')'));
  btn.dataset.type = type;
  btn.onclick = function() { toggleFilter(type, btn); };
  filterList.appendChild(btn);
}

// D3 Setup
const width = window.innerWidth;
const height = window.innerHeight - 44;

const svg = d3.select('#graph').append('svg').attr('width', width).attr('height', height);
const g = svg.append('g');

// Hull layer (drawn first = behind everything)
const hullGroup = g.append('g').attr('class', 'hulls');
const hullLabelGroup = g.append('g').attr('class', 'hull-labels');

const zoomBehavior = d3.zoom()
  .scaleExtent([0.1, 4])
  .on('zoom', function(event) { g.attr('transform', event.transform); });

svg.call(zoomBehavior);

// Graph data
const graphNodes = data.nodes.map(function(n) { return Object.assign({}, n); });
const graphLinks = data.edges.filter(function(e) { return e.type !== 'overlaps-with'; })
  .map(function(e) { return Object.assign({}, e); });

// Build domain groups from overlap edges
const domainMembers = {};  // domain -> Set of node IDs
data.edges.forEach(function(e) {
  if (e.type !== 'overlaps-with' || !e.meta || !e.meta.domains) return;
  e.meta.domains.forEach(function(domain) {
    if (!domainMembers[domain]) domainMembers[domain] = new Set();
    domainMembers[domain].add(e.source);
    domainMembers[domain].add(e.target);
  });
});

const DOMAIN_COLORS = {};
const DOMAIN_PALETTE = [
  '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
  '#DDA0DD', '#FF8C42', '#98D8C8', '#F7DC6F', '#BB8FCE',
  '#85C1E9'
];
var domainNames = Object.keys(domainMembers).sort();
domainNames.forEach(function(name, i) {
  DOMAIN_COLORS[name] = DOMAIN_PALETTE[i % DOMAIN_PALETTE.length];
});

const DOMAIN_LABELS = {};
domainNames.forEach(function(name) {
  DOMAIN_LABELS[name] = name.replace(/-/g, ' ').replace(/\b\w/g, function(c) { return c.toUpperCase(); });
});

const activeDomains = new Set(domainNames);

// Stats
document.getElementById('stats').textContent =
  data.stats.nodes + ' nodes \u00b7 ' + data.stats.edges + ' edges \u00b7 ' + domainNames.length + ' domains \u00b7 Generated ' + new Date(data.generated).toLocaleDateString();

// Build domain toggle buttons
var domainList = document.getElementById('domain-list');
domainNames.forEach(function(domain) {
  var btn = document.createElement('button');
  btn.className = 'filter-btn active';
  var color = DOMAIN_COLORS[domain];
  btn.style.setProperty('--type-color', color);
  var dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  var count = domainMembers[domain].size;
  btn.appendChild(document.createTextNode(DOMAIN_LABELS[domain] + ' (' + count + ')'));
  btn.dataset.domain = domain;
  btn.onclick = function() { toggleDomain(domain, btn); };
  domainList.appendChild(btn);
});

// Force simulation
const simulation = d3.forceSimulation(graphNodes)
  .force('link', d3.forceLink(graphLinks).id(function(d) { return d.id; }).distance(function(d) {
    if (d.type === 'part-of') return 100;
    if (d.type === 'companion-of') return 120;
    if (d.type === 'overlaps-with') return 90;
    if (d.type === 'provides-skill' || d.type === 'provides-agent') return 50;
    return 80;
  }))
  .force('charge', d3.forceManyBody().strength(function(d) {
    if (d.type === 'monorepo' || d.type === 'hub') return -400;
    if (d.type === 'plugin' || d.type === 'kernel') return -200;
    return -60;
  }))
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force('collision', d3.forceCollide().radius(function(d) { return (TYPE_SIZES[d.type] || 8) + 4; }));

// Draw links
const link = g.append('g').selectAll('line').data(graphLinks).join('line')
  .attr('class', function(d) { return 'link ' + d.type; })
  .attr('stroke-width', function(d) { return d.type === 'companion-of' ? 2 : 1; });

// Draw nodes
const node = g.append('g').selectAll('g').data(graphNodes).join('g')
  .attr('class', 'node')
  .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

node.append('circle')
  .attr('r', function(d) { return TYPE_SIZES[d.type] || 8; })
  .attr('fill', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
  .style('--glow', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
  .on('click', function(event, d) { event.stopPropagation(); selectNode(d); });

node.append('text')
  .attr('dx', function(d) { return (TYPE_SIZES[d.type] || 8) + 4; })
  .attr('dy', 3)
  .text(function(d) { return d.label; })
  .style('font-size', function(d) {
    if (d.type === 'monorepo' || d.type === 'hub') return '13px';
    if (d.type === 'plugin' || d.type === 'kernel' || d.type === 'service') return '11px';
    return '9px';
  });

svg.on('click', function() { deselectAll(); closePanel(); });

// Convex hull helper — takes [[x,y], ...], returns expanded hull path string
function computeHullPath(points, padding) {
  if (points.length < 2) return null;
  if (points.length === 2) {
    // Two-point "hull": draw a rounded rect between them
    var dx = points[1][0] - points[0][0];
    var dy = points[1][1] - points[0][1];
    var len = Math.sqrt(dx * dx + dy * dy) || 1;
    var nx = -dy / len * padding;
    var ny = dx / len * padding;
    return 'M' + (points[0][0] + nx) + ',' + (points[0][1] + ny) +
      'L' + (points[1][0] + nx) + ',' + (points[1][1] + ny) +
      'A' + padding + ',' + padding + ' 0 0,1 ' + (points[1][0] - nx) + ',' + (points[1][1] - ny) +
      'L' + (points[0][0] - nx) + ',' + (points[0][1] - ny) +
      'A' + padding + ',' + padding + ' 0 0,1 ' + (points[0][0] + nx) + ',' + (points[0][1] + ny) +
      'Z';
  }
  var hull = d3.polygonHull(points);
  if (!hull) return null;
  // Expand hull outward by padding
  var cx = d3.mean(hull, function(p) { return p[0]; });
  var cy = d3.mean(hull, function(p) { return p[1]; });
  var expanded = hull.map(function(p) {
    var dx = p[0] - cx;
    var dy = p[1] - cy;
    var dist = Math.sqrt(dx * dx + dy * dy) || 1;
    return [p[0] + dx / dist * padding, p[1] + dy / dist * padding];
  });
  return 'M' + expanded.map(function(p) { return p[0] + ',' + p[1]; }).join('L') + 'Z';
}

// Build node lookup for fast access
var nodeById = {};
graphNodes.forEach(function(n) { nodeById[n.id] = n; });

function updateHulls() {
  var hullData = [];
  domainNames.forEach(function(domain) {
    if (!activeDomains.has(domain)) return;
    var points = [];
    domainMembers[domain].forEach(function(id) {
      var n = nodeById[id];
      if (n && activeFilters.has(n.type)) points.push([n.x, n.y]);
    });
    if (points.length >= 2) {
      hullData.push({ domain: domain, points: points, color: DOMAIN_COLORS[domain] });
    }
  });

  var hulls = hullGroup.selectAll('path').data(hullData, function(d) { return d.domain; });
  hulls.exit().remove();
  hulls.enter().append('path')
    .attr('class', 'domain-hull')
    .merge(hulls)
    .attr('fill', function(d) { return d.color; })
    .attr('stroke', function(d) { return d.color; })
    .attr('d', function(d) { return computeHullPath(d.points, 30); });

  var labels = hullLabelGroup.selectAll('text').data(hullData, function(d) { return d.domain; });
  labels.exit().remove();
  labels.enter().append('text')
    .attr('class', 'domain-label')
    .merge(labels)
    .attr('fill', function(d) { return d.color; })
    .attr('x', function(d) { return d3.mean(d.points, function(p) { return p[0]; }); })
    .attr('y', function(d) { return d3.min(d.points, function(p) { return p[1]; }) - 35; })
    .text(function(d) { return DOMAIN_LABELS[d.domain]; });
}

simulation.on('tick', function() {
  link.attr('x1', function(d) { return d.source.x; })
    .attr('y1', function(d) { return d.source.y; })
    .attr('x2', function(d) { return d.target.x; })
    .attr('y2', function(d) { return d.target.y; });
  node.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
  updateHulls();
});

// --- Interaction ---

function getNodeId(n) { return typeof n === 'object' ? n.id : n; }

function selectNode(d) {
  selectedNode = d;
  var connectedIds = new Set([d.id]);
  graphLinks.forEach(function(l) {
    if (getNodeId(l.source) === d.id) connectedIds.add(getNodeId(l.target));
    if (getNodeId(l.target) === d.id) connectedIds.add(getNodeId(l.source));
  });

  node.classed('highlighted', function(n) { return connectedIds.has(n.id); });
  node.classed('dimmed', function(n) { return !connectedIds.has(n.id); });
  link.classed('highlighted', function(l) { return getNodeId(l.source) === d.id || getNodeId(l.target) === d.id; });
  link.classed('dimmed', function(l) { return getNodeId(l.source) !== d.id && getNodeId(l.target) !== d.id; });

  showDetailPanel(d);
}

function deselectAll() {
  selectedNode = null;
  node.classed('highlighted', false).classed('dimmed', false);
  link.classed('highlighted', false).classed('dimmed', false);
}

function showDetailPanel(d) {
  var panel = document.getElementById('detail-panel');
  var content = document.getElementById('panel-content');
  var color = TYPE_COLORS[d.type] || '#8b949e';

  // Find children and parents
  var children = [], parents = [];
  graphLinks.forEach(function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);

    if (l.type === 'part-of') return;

    // Overlap is symmetric; show in one "Overlaps" section regardless of edge direction.
    if (l.type === 'overlaps-with') {
      if (sid === d.id || tid === d.id) {
        var otherId = sid === d.id ? tid : sid;
        var otherNode = graphNodes.find(function(n) { return n.id === otherId; });
        if (otherNode) children.push(Object.assign({ edgeType: l.type, edgeMeta: l.meta || {} }, otherNode));
      }
      return;
    }

    if (sid === d.id) {
      var tn = graphNodes.find(function(n) { return n.id === tid; });
      if (tn) children.push(Object.assign({ edgeType: l.type, edgeMeta: l.meta || {} }, tn));
    }
    if (tid === d.id) {
      var sn = graphNodes.find(function(n) { return n.id === sid; });
      if (sn) parents.push(Object.assign({ edgeType: l.type, edgeMeta: l.meta || {} }, sn));
    }
  });

  // Build panel content using DOM methods (safe against injection)
  while (content.firstChild) content.removeChild(content.firstChild);

  var h2 = document.createElement('h2');
  h2.textContent = d.label;
  content.appendChild(h2);

  var badge = document.createElement('div');
  badge.className = 'type-badge';
  badge.style.cssText = 'background:' + color + '22;color:' + color + ';border:1px solid ' + color;
  badge.textContent = TYPE_LABELS[d.type];
  content.appendChild(badge);

  if (d.description) {
    var desc = document.createElement('div');
    desc.className = 'description';
    desc.textContent = d.description;
    content.appendChild(desc);
  }

  // Meta
  if (d.meta) {
    var metaFields = [
      ['Version', d.meta.version], ['Path', d.meta.path],
      ['Commands', d.meta.commandCount], ['Plugin', d.meta.plugin]
    ];
    metaFields.forEach(function(pair) {
      if (!pair[1]) return;
      var mi = document.createElement('div');
      mi.className = 'meta-item';
      mi.textContent = pair[0] + ': ';
      var sp = document.createElement('span');
      sp.textContent = pair[1];
      mi.appendChild(sp);
      content.appendChild(mi);
    });
  }

  // External links
  var links = [];
  if (d.meta && d.meta.repoUrl) {
    links.push({ label: 'GitHub repo', url: d.meta.repoUrl });
  }
  if (d.type === 'hook-event' && d.meta && d.meta.docsUrl) {
    links.push({ label: 'Claude Code hooks docs', url: d.meta.docsUrl });
  }
  if (links.length > 0) {
    var linksTitle = document.createElement('div');
    linksTitle.className = 'section-title';
    linksTitle.textContent = 'Links';
    content.appendChild(linksTitle);

    var linksList = document.createElement('ul');
    linksList.className = 'child-list';
    links.forEach(function(item) {
      var li = document.createElement('li');
      li.style.borderLeft = '2px solid ' + color;
      li.style.cursor = 'default';
      var a = document.createElement('a');
      a.href = item.url;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      a.textContent = item.label;
      a.onclick = function(event) { event.stopPropagation(); };
      li.appendChild(a);
      linksList.appendChild(li);
    });
    content.appendChild(linksList);
  }

  // Children grouped by edge type
  if (children.length > 0) {
    var grouped = {};
    children.forEach(function(c) {
      if (!grouped[c.edgeType]) grouped[c.edgeType] = [];
      grouped[c.edgeType].push(c);
    });

    var sectionLabels = {
      'provides-skill': 'Skills', 'provides-agent': 'Agents', 'provides-mcp': 'MCP Servers',
      'fires-hook': 'Hook Events', 'companion-of': 'Companions', 'depends-on': 'Dependencies',
      'overlaps-with': 'Overlaps'
    };

    Object.keys(grouped).forEach(function(edgeType) {
      var title = document.createElement('div');
      title.className = 'section-title';
      title.textContent = sectionLabels[edgeType] || edgeType;
      content.appendChild(title);

      var ul = document.createElement('ul');
      ul.className = 'child-list';
      grouped[edgeType].forEach(function(item) {
        var li = document.createElement('li');
        li.style.borderLeft = '2px solid ' + (TYPE_COLORS[item.type] || '#8b949e');
        li.textContent = item.label + ' ';
        var typeSpan = document.createElement('span');
        typeSpan.className = 'child-type';
        if (item.edgeType === 'overlaps-with') {
          var overlapScore = item.edgeMeta && typeof item.edgeMeta.score === 'number'
            ? item.edgeMeta.score.toFixed(2)
            : 'n/a';
          var overlapDomains = item.edgeMeta && Array.isArray(item.edgeMeta.domains) && item.edgeMeta.domains.length > 0
            ? ' [' + item.edgeMeta.domains.join(', ') + ']'
            : '';
          typeSpan.textContent = TYPE_LABELS[item.type] + ' · score ' + overlapScore + overlapDomains;
        } else {
          typeSpan.textContent = TYPE_LABELS[item.type];
        }
        li.appendChild(typeSpan);
        li.onclick = function() { navigateTo(item.id); };
        ul.appendChild(li);
      });
      content.appendChild(ul);
    });
  }

  // Parents
  if (parents.length > 0) {
    var pTitle = document.createElement('div');
    pTitle.className = 'section-title';
    pTitle.textContent = 'Provided by';
    content.appendChild(pTitle);

    var pUl = document.createElement('ul');
    pUl.className = 'child-list';
    parents.forEach(function(p) {
      var li = document.createElement('li');
      li.style.borderLeft = '2px solid ' + (TYPE_COLORS[p.type] || '#8b949e');
      li.textContent = p.label + ' ';
      var ts = document.createElement('span');
      ts.className = 'child-type';
      ts.textContent = TYPE_LABELS[p.type];
      li.appendChild(ts);
      li.onclick = function() { navigateTo(p.id); };
      pUl.appendChild(li);
    });
    content.appendChild(pUl);
  }

  panel.classList.add('open');
}

function closePanel() { document.getElementById('detail-panel').classList.remove('open'); }

function navigateTo(nodeId) {
  var targetNode = graphNodes.find(function(n) { return n.id === nodeId; });
  if (targetNode) {
    selectNode(targetNode);
    var transform = d3.zoomTransform(svg.node());
    var x = width / 2 - targetNode.x * transform.k;
    var y = height / 2 - targetNode.y * transform.k;
    svg.transition().duration(500).call(
      zoomBehavior.transform,
      d3.zoomIdentity.translate(x, y).scale(transform.k)
    );
  }
}

// Filters
function toggleFilter(type, btn) {
  if (activeFilters.has(type)) { activeFilters.delete(type); btn.classList.remove('active'); }
  else { activeFilters.add(type); btn.classList.add('active'); }
  applyFilters();
}

function showAll() {
  Object.keys(TYPE_COLORS).forEach(function(t) { activeFilters.add(t); });
  document.querySelectorAll('.filter-btn[data-type]').forEach(function(b) { b.classList.add('active'); });
  applyFilters();
}

function hideAll() {
  activeFilters.clear();
  document.querySelectorAll('.filter-btn[data-type]').forEach(function(b) { b.classList.remove('active'); });
  applyFilters();
}

function toggleDomain(domain, btn) {
  if (activeDomains.has(domain)) { activeDomains.delete(domain); btn.classList.remove('active'); }
  else { activeDomains.add(domain); btn.classList.add('active'); }
  updateHulls();
}

function showAllDomains() {
  domainNames.forEach(function(d) { activeDomains.add(d); });
  document.querySelectorAll('.filter-btn[data-domain]').forEach(function(b) { b.classList.add('active'); });
  updateHulls();
}

function hideAllDomains() {
  activeDomains.clear();
  document.querySelectorAll('.filter-btn[data-domain]').forEach(function(b) { b.classList.remove('active'); });
  updateHulls();
}

function toggleSidebar() {
  document.getElementById('filter-sidebar').classList.toggle('collapsed');
}

function applyFilters() {
  node.style('display', function(d) {
    if (!activeFilters.has(d.type)) return 'none';
    if (searchQuery && !d.label.toLowerCase().includes(searchQuery) && !d.id.toLowerCase().includes(searchQuery)) return 'none';
    return null;
  });
  link.style('display', function(l) {
    var sn = graphNodes.find(function(n) { return n.id === getNodeId(l.source); });
    var tn = graphNodes.find(function(n) { return n.id === getNodeId(l.target); });
    if (!sn || !tn || !activeFilters.has(sn.type) || !activeFilters.has(tn.type)) return 'none';
    return null;
  });
  updateHulls();
}

function onSearch(query) {
  searchQuery = query.toLowerCase().trim();
  applyFilters();
  if (searchQuery) {
    node.classed('highlighted', function(d) {
      return d.label.toLowerCase().includes(searchQuery) || d.id.toLowerCase().includes(searchQuery);
    });
    node.classed('dimmed', function(d) {
      return !(d.label.toLowerCase().includes(searchQuery) || d.id.toLowerCase().includes(searchQuery));
    });
  } else { deselectAll(); }
}

// Drag
function dragstarted(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x; d.fy = d.y;
}
function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
function dragended(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  d.fx = null; d.fy = null;
}

// Zoom to fit after layout settles
setTimeout(function() {
  var bounds = g.node().getBBox();
  var scale = 0.8 / Math.max(bounds.width / width, bounds.height / height);
  var midX = bounds.x + bounds.width / 2;
  var midY = bounds.y + bounds.height / 2;
  svg.transition().duration(750).call(
    zoomBehavior.transform,
    d3.zoomIdentity.translate(width / 2 - scale * midX, height / 2 - scale * midY).scale(scale)
  );
}, 2000);

// ═══════════════════════════════════════════════════════
// TAB SWITCHING
// ═══════════════════════════════════════════════════════

var sprintInitialized = false;

function switchTab(tabName) {
  // Update tab buttons
  var buttons = document.querySelectorAll('.tab-btn');
  for (var i = 0; i < buttons.length; i++) {
    if (buttons[i].dataset.tab === tabName) {
      buttons[i].classList.add('active');
    } else {
      buttons[i].classList.remove('active');
    }
  }

  // Update tab content
  var contents = document.querySelectorAll('.tab-content');
  for (var i = 0; i < contents.length; i++) {
    if (contents[i].id === 'tab-' + tabName) {
      contents[i].classList.add('active');
    } else {
      contents[i].classList.remove('active');
    }
  }

  // Ecosystem-specific toolbar elements
  var sidebarToggle = document.getElementById('sidebar-toggle');
  var searchBox = document.getElementById('search-box');
  var statsEl = document.getElementById('stats');

  if (tabName === 'ecosystem') {
    sidebarToggle.style.display = '';
    searchBox.style.display = '';
    statsEl.style.display = '';
    // Resume D3 simulation
    simulation.alphaTarget(0.01).restart();
    setTimeout(function() { simulation.alphaTarget(0); }, 500);
  } else {
    sidebarToggle.style.display = 'none';
    searchBox.style.display = 'none';
    statsEl.style.display = 'none';
    // Collapse sidebar and close panel
    document.getElementById('filter-sidebar').classList.add('collapsed');
    closePanel();
    // Pause D3 simulation
    simulation.stop();
  }

  // Lazy init sprint diagram
  if (tabName === 'sprint' && !sprintInitialized) {
    sprintInitialized = true;
    initSprintDiagram();
  }
}

// ═══════════════════════════════════════════════════════
// SPRINT WORKFLOW DIAGRAM
// ═══════════════════════════════════════════════════════

var SPRINT_PHASES = [
  {
    id: 'brainstorm', step: 1, label: 'Brainstorm',
    phase: 'ideation',
    command: 'bd create / /clavain brainstorm',
    description: 'Capture ideas freely. Explore the problem space, identify opportunities, and generate candidate solutions without filtering.',
    artifact: 'brainstorm doc',
    gate: null
  },
  {
    id: 'strategize', step: 2, label: 'Strategize',
    phase: 'ideation',
    command: '/clavain strategy',
    description: 'Structure brainstorm output into a PRD. Define features, create dependency graph, identify risks and tradeoffs.',
    artifact: 'PRD + feature beads',
    gate: null
  },
  {
    id: 'write-plan', step: 3, label: 'Write Plan',
    phase: 'planning',
    command: '/clavain write-plan',
    description: 'Break the strategy into bite-sized implementation tasks. Each task should be independently testable and mergeable.',
    artifact: 'implementation plan',
    gate: null
  },
  {
    id: 'review-plan', step: 4, label: 'Review Plan',
    phase: 'planning',
    command: '/clavain plan-review',
    description: 'Multi-agent review of the plan. Specialized agents check architecture, safety, correctness, and quality.',
    artifact: 'review verdict',
    gate: { type: 'soft', label: 'Plan approved' }
  },
  {
    id: 'execute', step: 5, label: 'Execute',
    phase: 'building',
    command: '/clavain execute-plan',
    description: 'Implement the plan in batches with review checkpoints. Each batch is a set of related tasks executed together.',
    artifact: 'code changes',
    gate: { type: 'hard', label: 'Plan exists' }
  },
  {
    id: 'test', step: 6, label: 'Test',
    phase: 'building',
    command: '/clavain tdd + /clavain verify',
    description: 'Run test suite, verify correctness. TDD for new code, verification before claiming completion.',
    artifact: 'test results',
    gate: null
  },
  {
    id: 'quality-gates', step: 7, label: 'Quality Gates',
    phase: 'quality',
    command: '/clavain quality-gates',
    description: 'Auto-select and run reviewer agents based on what changed. Architecture, safety, correctness, performance reviews.',
    artifact: 'review reports',
    gate: { type: 'hard', label: 'Tests pass' }
  },
  {
    id: 'resolve', step: 8, label: 'Resolve',
    phase: 'quality',
    command: '/clavain resolve',
    description: 'Address findings from quality gates. Fix issues, update code, re-run affected tests.',
    artifact: 'resolved findings',
    gate: null
  },
  {
    id: 'reflect', step: 9, label: 'Reflect',
    phase: 'learning',
    command: '/clavain reflect',
    description: 'Capture sprint learnings. What worked, what broke, what patterns to remember. Write to project memory.',
    artifact: 'learnings doc',
    gate: null
  },
  {
    id: 'ship', step: 10, label: 'Ship',
    phase: 'shipping',
    command: '/clavain land',
    description: 'Final landing workflow. Push to trunk, close beads, sync, verify deployment.',
    artifact: 'merged PR / pushed commits',
    gate: { type: 'soft', label: 'Findings resolved' }
  }
];

var PHASE_COLORS = {
  'ideation': '#F39C12',
  'planning': '#3498DB',
  'building': '#2ECC71',
  'quality': '#E74C3C',
  'learning': '#9B59B6',
  'shipping': '#1ABC9C'
};

var selectedSprintNode = null;

function initSprintDiagram() {
  var container = document.getElementById('sprint-container');
  var cw = container.clientWidth || window.innerWidth;
  var ch = container.clientHeight || (window.innerHeight - 44);

  var sprintSvg = d3.select('#sprint-container').append('svg')
    .attr('width', cw).attr('height', ch);

  var sprintG = sprintSvg.append('g');

  // Zoom/pan
  var sprintZoom = d3.zoom()
    .scaleExtent([0.3, 3])
    .on('zoom', function(event) { sprintG.attr('transform', event.transform); });
  sprintSvg.call(sprintZoom);

  // Click background to deselect
  sprintSvg.on('click', function() {
    selectedSprintNode = null;
    sprintG.selectAll('.sprint-node').classed('selected', false);
    closePanel();
  });

  // Layout: U-shape — top row L→R (steps 1-5), bottom row R→L (steps 6-10)
  var nodeW = 160, nodeH = 72;
  var hGap = 50, vGap = 120;
  var startX = 100, startY = 100;

  var positions = [];
  // Top row: steps 1-5
  for (var i = 0; i < 5; i++) {
    positions.push({ x: startX + i * (nodeW + hGap), y: startY });
  }
  // Bottom row: steps 6-10 (reversed)
  for (var i = 0; i < 5; i++) {
    positions.push({ x: startX + (4 - i) * (nodeW + hGap), y: startY + nodeH + vGap });
  }

  // Arrow marker
  sprintSvg.append('defs').append('marker')
    .attr('id', 'sprint-arrow')
    .attr('viewBox', '0 0 10 6')
    .attr('refX', 10).attr('refY', 3)
    .attr('markerWidth', 10).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,0 L10,3 L0,6 Z')
    .attr('fill', '#58a6ff');

  // Skip-path arrow marker (orange)
  sprintSvg.select('defs').append('marker')
    .attr('id', 'sprint-skip-arrow')
    .attr('viewBox', '0 0 10 6')
    .attr('refX', 10).attr('refY', 3)
    .attr('markerWidth', 10).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,0 L10,3 L0,6 Z')
    .attr('fill', '#F39C12');

  // Draw connecting arrows between consecutive steps
  var arrowGroup = sprintG.append('g').attr('class', 'sprint-arrows');

  for (var i = 0; i < 9; i++) {
    var from = positions[i];
    var to = positions[i + 1];

    if (i < 4) {
      // Top row: left to right
      arrowGroup.append('line')
        .attr('x1', from.x + nodeW).attr('y1', from.y + nodeH / 2)
        .attr('x2', to.x - 4).attr('y2', to.y + nodeH / 2)
        .attr('stroke', '#58a6ff').attr('stroke-width', 2)
        .attr('marker-end', 'url(#sprint-arrow)');
    } else if (i === 4) {
      // Turn: step 5 down to step 6
      var turnX = from.x + nodeW / 2;
      arrowGroup.append('path')
        .attr('d', 'M' + (from.x + nodeW / 2) + ',' + (from.y + nodeH) +
          ' L' + (from.x + nodeW / 2) + ',' + (to.y + nodeH / 2) +
          ' L' + (to.x + nodeW + 4) + ',' + (to.y + nodeH / 2))
        .attr('fill', 'none').attr('stroke', '#58a6ff').attr('stroke-width', 2)
        .attr('marker-end', 'url(#sprint-arrow)');
    } else {
      // Bottom row: right to left
      arrowGroup.append('line')
        .attr('x1', from.x).attr('y1', from.y + nodeH / 2)
        .attr('x2', to.x + nodeW + 4).attr('y2', to.y + nodeH / 2)
        .attr('stroke', '#58a6ff').attr('stroke-width', 2)
        .attr('marker-end', 'url(#sprint-arrow)');
    }
  }

  // Skip path: Brainstorm → Write Plan (dashed orange curve)
  var skipFrom = positions[0]; // Brainstorm
  var skipTo = positions[2];   // Write Plan
  var skipMidY = skipFrom.y - 50;
  arrowGroup.append('path')
    .attr('d', 'M' + (skipFrom.x + nodeW / 2) + ',' + skipFrom.y +
      ' C' + (skipFrom.x + nodeW / 2) + ',' + skipMidY +
      ' ' + (skipTo.x + nodeW / 2) + ',' + skipMidY +
      ' ' + (skipTo.x + nodeW / 2) + ',' + skipTo.y)
    .attr('fill', 'none').attr('stroke', '#F39C12').attr('stroke-width', 2)
    .attr('stroke-dasharray', '6 3')
    .attr('marker-end', 'url(#sprint-skip-arrow)');

  // Skip path label
  arrowGroup.append('text')
    .attr('x', (skipFrom.x + skipTo.x + nodeW) / 2)
    .attr('y', skipMidY - 6)
    .attr('text-anchor', 'middle')
    .attr('fill', '#F39C12').attr('font-size', '10px')
    .text('skip (trivial tasks)');

  // Draw gate indicators
  var gateGroup = sprintG.append('g').attr('class', 'sprint-gates');

  SPRINT_PHASES.forEach(function(phase, idx) {
    if (!phase.gate) return;
    var pos = positions[idx];
    var gateColor = phase.gate.type === 'hard' ? '#E74C3C' : '#F39C12';

    // Find the incoming arrow midpoint
    var gx, gy;
    if (idx < 5) {
      // Top row — gate before node (from left)
      gx = pos.x - hGap / 2;
      gy = pos.y + nodeH / 2;
    } else {
      // Bottom row — gate before node (from right)
      gx = pos.x + nodeW + hGap / 2;
      gy = pos.y + nodeH / 2;
    }

    var ds = 8; // diamond half-size
    gateGroup.append('path')
      .attr('class', 'gate-diamond')
      .attr('d', 'M' + gx + ',' + (gy - ds) +
        ' L' + (gx + ds) + ',' + gy +
        ' L' + gx + ',' + (gy + ds) +
        ' L' + (gx - ds) + ',' + gy + ' Z')
      .attr('fill', gateColor).attr('stroke', gateColor).attr('stroke-width', 1)
      .attr('opacity', 0.9);

    gateGroup.append('text')
      .attr('x', gx).attr('y', gy - ds - 5)
      .attr('text-anchor', 'middle')
      .attr('fill', gateColor).attr('font-size', '9px')
      .text(phase.gate.label);
  });

  // Draw nodes
  var nodeGroup = sprintG.append('g').attr('class', 'sprint-nodes');

  SPRINT_PHASES.forEach(function(phase, idx) {
    var pos = positions[idx];
    var color = PHASE_COLORS[phase.phase] || '#8b949e';

    var gNode = nodeGroup.append('g')
      .attr('class', 'sprint-node')
      .attr('transform', 'translate(' + pos.x + ',' + pos.y + ')')
      .style('cursor', 'pointer')
      .on('click', function(event) {
        event.stopPropagation();
        selectedSprintNode = phase;
        sprintG.selectAll('.sprint-node').classed('selected', false);
        d3.select(this).classed('selected', true);
        showSprintDetail(phase);
      });

    // Background rect
    gNode.append('rect')
      .attr('width', nodeW).attr('height', nodeH)
      .attr('rx', 8).attr('ry', 8)
      .attr('fill', '#161b22')
      .attr('stroke', color).attr('stroke-width', 2);

    // Step number circle
    gNode.append('circle')
      .attr('cx', 20).attr('cy', 20).attr('r', 12)
      .attr('fill', color).attr('opacity', 0.2);
    gNode.append('text')
      .attr('x', 20).attr('y', 24)
      .attr('text-anchor', 'middle')
      .attr('fill', color).attr('font-size', '12px').attr('font-weight', '700')
      .text(phase.step);

    // Label
    gNode.append('text')
      .attr('x', 40).attr('y', 24)
      .attr('fill', '#f0f6fc').attr('font-size', '13px').attr('font-weight', '600')
      .text(phase.label);

    // Phase name
    gNode.append('text')
      .attr('x', 12).attr('y', 52)
      .attr('fill', color).attr('font-size', '10px').attr('opacity', 0.7)
      .text(phase.phase);

    // Artifact hint
    gNode.append('text')
      .attr('x', nodeW - 8).attr('y', 52)
      .attr('text-anchor', 'end')
      .attr('fill', '#8b949e').attr('font-size', '9px')
      .text(phase.artifact);
  });

  // Zoom to fit
  setTimeout(function() {
    var bounds = sprintG.node().getBBox();
    var pad = 60;
    var scaleX = cw / (bounds.width + pad * 2);
    var scaleY = ch / (bounds.height + pad * 2);
    var fitScale = Math.min(scaleX, scaleY, 1.5);
    var midX = bounds.x + bounds.width / 2;
    var midY = bounds.y + bounds.height / 2;
    sprintSvg.transition().duration(500).call(
      sprintZoom.transform,
      d3.zoomIdentity
        .translate(cw / 2 - fitScale * midX, ch / 2 - fitScale * midY)
        .scale(fitScale)
    );
  }, 100);
}

function showSprintDetail(phase) {
  var panel = document.getElementById('detail-panel');
  var content = document.getElementById('panel-content');
  var color = PHASE_COLORS[phase.phase] || '#8b949e';

  while (content.firstChild) content.removeChild(content.firstChild);

  // Step header
  var h2 = document.createElement('h2');
  h2.textContent = 'Step ' + phase.step + ': ' + phase.label;
  content.appendChild(h2);

  // Phase badge
  var badge = document.createElement('div');
  badge.className = 'type-badge';
  badge.style.cssText = 'background:' + color + '22;color:' + color + ';border:1px solid ' + color;
  badge.textContent = phase.phase;
  content.appendChild(badge);

  // Description
  var desc = document.createElement('div');
  desc.className = 'description';
  desc.textContent = phase.description;
  content.appendChild(desc);

  // Command
  var cmdTitle = document.createElement('div');
  cmdTitle.className = 'section-title';
  cmdTitle.textContent = 'Command';
  content.appendChild(cmdTitle);

  var cmdBox = document.createElement('div');
  cmdBox.style.cssText = 'background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px 12px;font-family:monospace;font-size:12px;color:#50C878;margin-bottom:12px;';
  cmdBox.textContent = phase.command;
  content.appendChild(cmdBox);

  // Artifact
  var artTitle = document.createElement('div');
  artTitle.className = 'section-title';
  artTitle.textContent = 'Artifact';
  content.appendChild(artTitle);

  var artItem = document.createElement('div');
  artItem.className = 'meta-item';
  var artSpan = document.createElement('span');
  artSpan.textContent = phase.artifact;
  artItem.appendChild(artSpan);
  content.appendChild(artItem);

  // Gate
  if (phase.gate) {
    var gateTitle = document.createElement('div');
    gateTitle.className = 'section-title';
    gateTitle.textContent = 'Gate';
    content.appendChild(gateTitle);

    var gateColor = phase.gate.type === 'hard' ? '#E74C3C' : '#F39C12';
    var gateBadge = document.createElement('div');
    gateBadge.className = 'type-badge';
    gateBadge.style.cssText = 'background:' + gateColor + '22;color:' + gateColor + ';border:1px solid ' + gateColor;
    gateBadge.textContent = phase.gate.type.toUpperCase() + ' — ' + phase.gate.label;
    content.appendChild(gateBadge);

    var gateDesc = document.createElement('div');
    gateDesc.className = 'description';
    gateDesc.textContent = phase.gate.type === 'hard'
      ? 'This gate blocks progress. The condition must be met before proceeding.'
      : 'This gate is advisory. It can be bypassed but doing so is flagged.';
    content.appendChild(gateDesc);
  }

  panel.classList.add('open');
}
</script>
</body>
</html>
