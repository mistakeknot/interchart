<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Interverse Ecosystem</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #0d1117;
  color: #c9d1d9;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
}

#toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
  background: #161b22;
  border-bottom: 1px solid #30363d;
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  height: 44px;
}

#toolbar .title {
  font-weight: 600;
  font-size: 14px;
  color: #f0f6fc;
  white-space: nowrap;
}

#toolbar .stats {
  font-size: 11px;
  color: #8b949e;
  white-space: nowrap;
}

#filter-sidebar {
  position: fixed;
  top: 44px;
  left: 0;
  width: 240px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-right: 1px solid #30363d;
  z-index: 90;
  overflow-y: auto;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  transition: transform 0.25s ease, opacity 0.25s ease;
}
#filter-sidebar.collapsed {
  transform: translateX(-240px);
  opacity: 0;
  pointer-events: none;
}

#filter-sidebar .sidebar-title {
  font-size: 11px;
  font-weight: 600;
  color: #8b949e;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 4px;
}

#filter-sidebar .meta-row {
  display: flex;
  gap: 4px;
  margin-bottom: 8px;
}

#filter-list, #domain-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  border-top: 1px solid #30363d;
  padding-top: 8px;
}

.filter-btn {
  border: 1px solid #30363d;
  background: transparent;
  color: #8b949e;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
  width: 100%;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 6px;
}

.filter-btn .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}

.filter-btn.active {
  border-color: var(--type-color);
  color: var(--type-color);
  background: color-mix(in srgb, var(--type-color) 12%, transparent);
}

.filter-btn:hover { border-color: #58a6ff; }

.filter-btn.meta {
  font-weight: 600;
  border-color: #58a6ff;
  color: #58a6ff;
  width: 100%;
  flex: 0 0 auto;
  text-align: left;
  justify-content: flex-start;
  padding: 3px 8px;
  font-size: 10px;
}

#filter-sidebar .meta-row .filter-btn.meta {
  width: auto;
  flex: 1;
  text-align: center;
  justify-content: center;
  font-size: 11px;
  padding: 4px 10px;
}

.filter-btn.meta:hover { background: rgba(88, 166, 255, 0.1); }

#sidebar-toggle {
  position: fixed; top: 52px; left: 8px; z-index: 95;
  background: #161b22; border: 1px solid #30363d; color: #8b949e;
  width: 32px; height: 32px; border-radius: 6px; cursor: pointer;
  font-size: 16px; display: flex; align-items: center; justify-content: center;
  transition: all 0.15s;
}
#sidebar-toggle:hover { border-color: #58a6ff; color: #58a6ff; }

#search-box {
  border: 1px solid #30363d; background: #0d1117; color: #c9d1d9;
  padding: 4px 10px; border-radius: 6px; font-size: 12px;
  width: 160px; margin-left: auto;
}
#search-box:focus { outline: none; border-color: #58a6ff; }

#graph { width: 100vw; height: 100vh; padding-top: 44px; }
#graph svg { width: 100%; height: 100%; }

.node circle { cursor: pointer; transition: opacity 0.2s; }
.node circle:hover { filter: brightness(1.3); }
.node text { font-size: 10px; fill: #8b949e; pointer-events: none; user-select: none; }
.node.leaf-node text { opacity: 0; transition: opacity 0.15s; }
.node.leaf-node:hover text { opacity: 1; }
.node.leaf-node.highlighted text { opacity: 1; }

.link { stroke-opacity: 0.12; transition: stroke-opacity 0.2s; }
.link.provides-skill { stroke: #50C878; }
.link.provides-agent { stroke: #FF8C42; }
.link.provides-mcp { stroke: #9B59B6; stroke-dasharray: 4 2; }
.link.fires-hook { stroke: #E74C3C; stroke-dasharray: 2 2; }
.link.companion-of { stroke: #F39C12; stroke-dasharray: 6 3; stroke-width: 2; stroke-opacity: 0.3; }
.link.depends-on { stroke: #1ABC9C; stroke-dasharray: 4 4; stroke-opacity: 0.3; }
.link.part-of { stroke: #30363d; stroke-opacity: 0.2; }

.phase-arc {
  fill: none;
  stroke-width: 6;
  stroke-opacity: 0.5;
  stroke-linecap: round;
  pointer-events: none;
  filter: drop-shadow(0 0 4px var(--arc-color));
}
.phase-arc-dot {
  stroke: none;
  opacity: 0.7;
  pointer-events: none;
}

.domain-hull {
  fill-opacity: 0.08;
  stroke-opacity: 0.35;
  stroke-width: 1.5;
  stroke-dasharray: 6 3;
  pointer-events: none;
  transition: fill-opacity 0.3s, stroke-opacity 0.3s;
}
.domain-hull:hover { fill-opacity: 0.14; stroke-opacity: 0.5; }
.domain-hull.hidden { fill-opacity: 0; stroke-opacity: 0; }
.hulls-dimmed .domain-hull { fill-opacity: 0.03; stroke-opacity: 0.12; }
.hulls-dimmed .domain-label { fill-opacity: 0.15; }

.domain-label {
  font-size: 9px;
  font-weight: 600;
  fill-opacity: 0.4;
  pointer-events: none;
  text-anchor: middle;
}

.dimmed circle { opacity: 0.1; }
.dimmed text { opacity: 0.1; }
.link.dimmed { stroke-opacity: 0.02; }

.highlighted circle { filter: brightness(1.4) drop-shadow(0 0 6px var(--glow)); }
.highlighted text { fill: #f0f6fc; font-weight: 600; }
.link.highlighted { stroke-opacity: 0.8; stroke-width: 2; }

#detail-panel {
  position: fixed;
  top: 44px;
  right: -360px;
  width: 340px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-left: 1px solid #30363d;
  z-index: 90;
  transition: right 0.25s ease;
  overflow-y: auto;
  padding: 20px;
}

#detail-panel.open { right: 0; }

#detail-panel .close-btn {
  position: absolute; top: 12px; right: 12px;
  background: none; border: none; color: #8b949e; cursor: pointer; font-size: 18px;
}
#detail-panel .close-btn:hover { color: #f0f6fc; }

#detail-panel h2 { font-size: 18px; color: #f0f6fc; margin-bottom: 4px; padding-right: 24px; }

#detail-panel .type-badge {
  display: inline-block; padding: 2px 8px; border-radius: 10px;
  font-size: 11px; font-weight: 600; margin-bottom: 12px;
}

#detail-panel .description { font-size: 13px; color: #8b949e; line-height: 1.5; margin-bottom: 16px; }

#detail-panel .section-title {
  font-size: 12px; font-weight: 600; color: #58a6ff;
  text-transform: uppercase; letter-spacing: 0.5px;
  margin-top: 16px; margin-bottom: 8px;
}

#detail-panel .child-list { list-style: none; padding: 0; }
#detail-panel .child-list li {
  font-size: 12px; color: #c9d1d9; padding: 3px 0 3px 8px; cursor: pointer;
}
#detail-panel .child-list li:hover { color: #58a6ff; }
#detail-panel .child-list a { color: #58a6ff; text-decoration: none; }
#detail-panel .child-list a:hover { text-decoration: underline; }
#detail-panel .child-type { font-size: 10px; color: #8b949e; margin-left: 4px; }

#detail-panel .meta-item { font-size: 12px; color: #8b949e; margin-bottom: 4px; }
#detail-panel .meta-item span { color: #c9d1d9; }

/* Toggle bar */
#toggle-bar {
  display: flex;
  gap: 4px;
  margin-left: 8px;
}

.toggle-btn {
  background: transparent;
  border: 1px solid #30363d;
  color: #8b949e;
  padding: 3px 12px;
  border-radius: 14px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}
.toggle-btn:hover { border-color: #58a6ff; color: #c9d1d9; }
.toggle-btn.active {
  background: rgba(88, 166, 255, 0.15);
  border-color: #58a6ff;
  color: #58a6ff;
}

/* Sprint phase nodes in force graph */
.sprint-phase-node rect {
  cursor: pointer;
  transition: filter 0.15s;
}
.sprint-phase-node rect:hover { filter: brightness(1.3); }
.sprint-phase-node text { pointer-events: none; user-select: none; }
.sprint-phase-node.highlighted rect {
  filter: brightness(1.4) drop-shadow(0 0 8px rgba(88, 166, 255, 0.6));
}
.sprint-phase-node.dimmed rect { opacity: 0.1; }
.sprint-phase-node.dimmed text { opacity: 0.1; }

/* Participates-in edges */
.link.participates-in {
  stroke: #45B7D1;
  stroke-dasharray: 4 3;
  stroke-opacity: 0.35;
  stroke-width: 1.5;
}
.link.participates-in.highlighted { stroke-opacity: 0.8; stroke-width: 2; }
.link.participates-in.dimmed { stroke-opacity: 0.03; }

/* Sprint flow arrows (decorative layer) */
.sprint-flow-arrow { pointer-events: none; }
.gate-diamond { pointer-events: none; }

/* Spotlight layer — on-demand bezier curves for tier-2 skill/agent connections */
.spotlight-layer path {
  pointer-events: none;
  filter: drop-shadow(0 0 4px rgba(69, 183, 209, 0.5));
}

</style>
</head>
<body>

<div id="toolbar">
  <span class="title">Interverse</span>
  <div id="toggle-bar">
    <button class="toggle-btn active" id="toggle-ecosystem" onclick="toggleLayer('ecosystem')">Ecosystem</button>
    <button class="toggle-btn" id="toggle-sprint" onclick="toggleLayer('sprint')">Sprint</button>
    <button class="toggle-btn" id="toggle-hooks" onclick="toggleHookEdges()" style="font-size:11px;padding:4px 8px;opacity:0.6">Hooks</button>
  </div>
  <span class="stats" id="stats"></span>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>

<button id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle filters">&#9776;</button>
<div id="filter-sidebar" class="collapsed">
  <div class="sidebar-title">Filters</div>
  <div class="meta-row">
    <button class="filter-btn meta" onclick="showAll()">All</button>
    <button class="filter-btn meta" onclick="hideAll()">None</button>
  </div>
  <div id="filter-list"></div>
  <div class="sidebar-title" style="margin-top: 12px">Domains</div>
  <div class="meta-row">
    <button class="filter-btn meta" onclick="showAllDomains()">All</button>
    <button class="filter-btn meta" onclick="hideAllDomains()">None</button>
  </div>
  <div id="domain-list"></div>
  <div id="phase-filter-section" style="display:none">
    <div class="sidebar-title" style="margin-top: 12px">Sprint Phases</div>
    <div class="meta-row">
      <button class="filter-btn meta" onclick="showAllPhases()">All</button>
      <button class="filter-btn meta" onclick="hideAllPhases()">None</button>
    </div>
    <div id="phase-list"></div>
  </div>
</div>

<div id="graph"></div>

<div id="detail-panel">
  <button class="close-btn" onclick="closePanel()">&times;</button>
  <div id="panel-content"></div>
</div>


<script>
// DATA_PLACEHOLDER is replaced by the generator with scanned JSON
const data = /*DATA_PLACEHOLDER*/;

const TYPE_COLORS = {
  'plugin': '#4A90D9', 'skill': '#50C878', 'agent': '#FF8C42',
  'mcp-server': '#9B59B6', 'hook-event': '#E74C3C', 'hub': '#F39C12',
  'kernel': '#1ABC9C', 'service': '#E74C3C', 'sdk': '#95A5A6',
  'tui': '#E91E63', 'monorepo': '#58a6ff'
};

const TYPE_SIZES = {
  'monorepo': 24, 'hub': 20, 'kernel': 16, 'service': 14, 'tui': 14,
  'sdk': 12, 'plugin': 12, 'skill': 6, 'agent': 6, 'mcp-server': 7, 'hook-event': 7
};

const TYPE_LABELS = {
  'plugin': 'Plugin', 'skill': 'Skill', 'agent': 'Agent', 'mcp-server': 'MCP Server',
  'hook-event': 'Hook Event', 'hub': 'Hub', 'kernel': 'Kernel', 'service': 'Service',
  'sdk': 'SDK', 'tui': 'TUI', 'monorepo': 'Monorepo'
};

// State
const activeFilters = new Set(Object.keys(TYPE_COLORS));
let selectedNode = null;
let searchQuery = '';

// Stats (updated after domain extraction below)

// Build filter buttons into sidebar
const filterList = document.getElementById('filter-list');
for (const [type, color] of Object.entries(TYPE_COLORS)) {
  const count = data.stats.byType[type] || 0;
  if (count === 0) continue;
  const btn = document.createElement('button');
  btn.className = 'filter-btn active';
  btn.style.setProperty('--type-color', color);
  const dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  btn.appendChild(document.createTextNode(TYPE_LABELS[type] + ' (' + count + ')'));
  btn.dataset.type = type;
  btn.onclick = function() { toggleFilter(type, btn); };
  filterList.appendChild(btn);
}

// D3 Setup
const width = window.innerWidth;
const height = window.innerHeight - 44;

const svg = d3.select('#graph').append('svg').attr('width', width).attr('height', height);
const g = svg.append('g');

// Hull layer (drawn first = behind everything)
const hullGroup = g.append('g').attr('class', 'hulls');
const hullLabelGroup = g.append('g').attr('class', 'hull-labels');

const zoomBehavior = d3.zoom()
  .scaleExtent([0.1, 4])
  .on('zoom', function(event) { g.attr('transform', event.transform); });

svg.call(zoomBehavior);

// Graph data
const graphNodes = data.nodes.map(function(n) { return Object.assign({}, n); });
const graphLinks = data.edges.filter(function(e) { return e.type !== 'overlaps-with'; })
  .map(function(e) { return Object.assign({}, e); });

// Build domain groups from overlap edges
const domainMembers = {};  // domain -> Set of node IDs
data.edges.forEach(function(e) {
  if (e.type !== 'overlaps-with' || !e.meta || !e.meta.domains) return;
  e.meta.domains.forEach(function(domain) {
    if (!domainMembers[domain]) domainMembers[domain] = new Set();
    domainMembers[domain].add(e.source);
    domainMembers[domain].add(e.target);
  });
});

const DOMAIN_COLORS = {};
const DOMAIN_PALETTE = [
  '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
  '#DDA0DD', '#FF8C42', '#98D8C8', '#F7DC6F', '#BB8FCE',
  '#85C1E9'
];
var domainNames = Object.keys(domainMembers).sort();
domainNames.forEach(function(name, i) {
  DOMAIN_COLORS[name] = DOMAIN_PALETTE[i % DOMAIN_PALETTE.length];
});

const DOMAIN_LABELS = {};
domainNames.forEach(function(name) {
  DOMAIN_LABELS[name] = name.replace(/-/g, ' ').replace(/\b\w/g, function(c) { return c.toUpperCase(); });
});

const activeDomains = new Set(domainNames);

// Stats
document.getElementById('stats').textContent =
  data.stats.nodes + ' nodes \u00b7 ' + data.stats.edges + ' edges \u00b7 ' + domainNames.length + ' domains \u00b7 Generated ' + new Date(data.generated).toLocaleDateString();

// Build domain toggle buttons
var domainList = document.getElementById('domain-list');
domainNames.forEach(function(domain) {
  var btn = document.createElement('button');
  btn.className = 'filter-btn active';
  var color = DOMAIN_COLORS[domain];
  btn.style.setProperty('--type-color', color);
  var dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  var count = domainMembers[domain].size;
  btn.appendChild(document.createTextNode(DOMAIN_LABELS[domain] + ' (' + count + ')'));
  btn.dataset.domain = domain;
  btn.onclick = function() { toggleDomain(domain, btn); };
  domainList.appendChild(btn);
});

// Force simulation
var simulation = d3.forceSimulation(graphNodes)
  .force('link', d3.forceLink(graphLinks).id(function(d) { return d.id; }).distance(function(d) {
    if (d.type === 'participates-in') return 280;
    if (d.type === 'part-of') return 140;
    if (d.type === 'companion-of') return 160;
    if (d.type === 'fires-hook') return 180;
    if (d.type === 'provides-skill' || d.type === 'provides-agent') return 140;
    if (d.type === 'provides-mcp') return 120;
    return 120;
  }).strength(function(d) {
    // Weaken pull for high-density edge types so nodes spread more
    if (d.type === 'provides-skill' || d.type === 'fires-hook') return 0.08;
    if (d.type === 'provides-agent' || d.type === 'provides-mcp') return 0.1;
    if (d.type === 'part-of') return 0.3;
    return 0.2;
  }))
  .force('charge', d3.forceManyBody().strength(function(d) {
    if (d.type === 'sprint-phase') return -800;
    if (d.type === 'monorepo') return -1200;
    if (d.type === 'hub') return -900;
    if (d.type === 'plugin' || d.type === 'kernel') return -400;
    return -120;
  }).distanceMax(600))
  .force('center', d3.forceCenter(width / 2, height / 2).strength(0.02))
  .force('radial', d3.forceRadial(function(d) {
    // Concentric rings: core anchors stay center, plugins mid-ring, leaves outer
    if (d.type === 'monorepo' || d.type === 'hub') return 0;
    if (d.type === 'sprint-phase') return 0; // pinned by fx/fy
    if (d.type === 'plugin' || d.type === 'kernel' || d.type === 'service') return Math.min(width, height) * 0.22;
    return Math.min(width, height) * 0.35;
  }, width / 2, height / 2).strength(function(d) {
    if (d.type === 'monorepo' || d.type === 'hub') return 0;
    if (d.type === 'sprint-phase') return 0;
    if (d.type === 'plugin' || d.type === 'kernel' || d.type === 'service') return 0.4;
    return 0.5;
  }))
  .force('collision', d3.forceCollide().radius(function(d) {
    if (d.type === 'sprint-phase') return 120;
    if (d.type === 'monorepo' || d.type === 'hub') return 35;
    if (d.type === 'plugin' || d.type === 'kernel') return 20;
    return (TYPE_SIZES[d.type] || 8) + 8;
  }));

// Draw links
var linkGroup = g.append('g').attr('class', 'links');
var link = linkGroup.selectAll('line').data(graphLinks).join('line')
  .attr('class', function(d) { return 'link ' + d.type; })
  .attr('stroke-width', function(d) { return d.type === 'companion-of' ? 2 : 1; });

// Draw nodes
var CORE_TYPES = { monorepo: 1, hub: 1, plugin: 1, kernel: 1, service: 1 };
var nodeGroup_eco = g.append('g').attr('class', 'nodes');
var node = nodeGroup_eco.selectAll('g').data(graphNodes).join('g')
  .attr('class', function(d) { return 'node' + (CORE_TYPES[d.type] ? '' : ' leaf-node'); })
  .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

node.append('circle')
  .attr('r', function(d) { return TYPE_SIZES[d.type] || 8; })
  .attr('fill', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
  .style('--glow', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
  .on('click', function(event, d) { event.stopPropagation(); selectNode(d); });

node.append('text')
  .attr('dx', function(d) { return (TYPE_SIZES[d.type] || 8) + 4; })
  .attr('dy', 3)
  .text(function(d) { return d.label; })
  .style('font-size', function(d) {
    if (d.type === 'monorepo' || d.type === 'hub') return '13px';
    if (d.type === 'plugin' || d.type === 'kernel' || d.type === 'service') return '11px';
    return '9px';
  });

svg.on('click', function() { deselectAll(); closePanel(); });

// Convex hull helper — takes [[x,y], ...], returns expanded hull path string
function computeHullPath(points, padding) {
  if (points.length < 2) return null;
  if (points.length === 2) {
    // Two-point "hull": draw a rounded rect between them
    var dx = points[1][0] - points[0][0];
    var dy = points[1][1] - points[0][1];
    var len = Math.sqrt(dx * dx + dy * dy) || 1;
    var nx = -dy / len * padding;
    var ny = dx / len * padding;
    return 'M' + (points[0][0] + nx) + ',' + (points[0][1] + ny) +
      'L' + (points[1][0] + nx) + ',' + (points[1][1] + ny) +
      'A' + padding + ',' + padding + ' 0 0,1 ' + (points[1][0] - nx) + ',' + (points[1][1] - ny) +
      'L' + (points[0][0] - nx) + ',' + (points[0][1] - ny) +
      'A' + padding + ',' + padding + ' 0 0,1 ' + (points[0][0] + nx) + ',' + (points[0][1] + ny) +
      'Z';
  }
  var hull = d3.polygonHull(points);
  if (!hull) return null;
  // Expand hull outward by padding
  var cx = d3.mean(hull, function(p) { return p[0]; });
  var cy = d3.mean(hull, function(p) { return p[1]; });
  var expanded = hull.map(function(p) {
    var dx = p[0] - cx;
    var dy = p[1] - cy;
    var dist = Math.sqrt(dx * dx + dy * dy) || 1;
    return [p[0] + dx / dist * padding, p[1] + dy / dist * padding];
  });
  return 'M' + expanded.map(function(p) { return p[0] + ',' + p[1]; }).join('L') + 'Z';
}

// Build node lookup for fast access
var nodeById = {};
graphNodes.forEach(function(n) { nodeById[n.id] = n; });

function updateHulls() {
  var hullData = [];
  domainNames.forEach(function(domain) {
    if (!activeDomains.has(domain)) return;
    var points = [];
    domainMembers[domain].forEach(function(id) {
      var n = nodeById[id];
      if (n && activeFilters.has(n.type)) points.push([n.x, n.y]);
    });
    if (points.length >= 2) {
      hullData.push({ domain: domain, points: points, color: DOMAIN_COLORS[domain] });
    }
  });

  var hulls = hullGroup.selectAll('path').data(hullData, function(d) { return d.domain; });
  hulls.exit().remove();
  hulls.enter().append('path')
    .attr('class', 'domain-hull')
    .merge(hulls)
    .attr('fill', function(d) { return d.color; })
    .attr('stroke', function(d) { return d.color; })
    .attr('d', function(d) { return computeHullPath(d.points, 30); });

  var labels = hullLabelGroup.selectAll('text').data(hullData, function(d) { return d.domain; });
  labels.exit().remove();
  labels.enter().append('text')
    .attr('class', 'domain-label')
    .merge(labels)
    .attr('fill', function(d) { return d.color; })
    .attr('x', function(d) { return d3.mean(d.points, function(p) { return p[0]; }); })
    .attr('y', function(d) { return d3.min(d.points, function(p) { return p[1]; }) - 35; })
    .text(function(d) { return DOMAIN_LABELS[d.domain]; });
}

simulation.on('tick', function() {
  link.attr('x1', function(d) { return d.source.x; })
    .attr('y1', function(d) { return d.source.y; })
    .attr('x2', function(d) { return d.target.x; })
    .attr('y2', function(d) { return d.target.y; });
  node.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
  // Update sprint phase node positions (they live in a separate group)
  var sprintNodeW = 160, sprintNodeH = 56;
  sprintNodeGroup.selectAll('.sprint-phase-node').each(function() {
    var el = d3.select(this);
    var nodeId = el.attr('data-id');
    var sn = nodeById[nodeId];
    if (sn) el.attr('transform', 'translate(' + (sn.x - sprintNodeW / 2) + ',' + (sn.y - sprintNodeH / 2) + ')');
  });
  // Redraw flow arrows to follow sprint node positions
  if (sprintActive) {
    sprintFlowGroup.selectAll('*').remove();
    drawSprintFlowArrows();
  }
  updateHulls();
  updateSpotlightPaths();
});

// Apply initial filters (hides hook edges, etc.)
applyFilters();

// --- Interaction ---

function getNodeId(n) { return typeof n === 'object' ? n.id : n; }

function selectNode(d) {
  selectedNode = d;
  var connectedIds = new Set([d.id]);
  graphLinks.forEach(function(l) {
    if (getNodeId(l.source) === d.id) connectedIds.add(getNodeId(l.target));
    if (getNodeId(l.target) === d.id) connectedIds.add(getNodeId(l.source));
  });

  node.classed('highlighted', function(n) { return connectedIds.has(n.id); });
  node.classed('dimmed', function(n) { return !connectedIds.has(n.id); });
  link.classed('highlighted', function(l) { return getNodeId(l.source) === d.id || getNodeId(l.target) === d.id; });
  link.classed('dimmed', function(l) { return getNodeId(l.source) !== d.id && getNodeId(l.target) !== d.id; });

  // Also highlight/dim sprint phase nodes if sprint is active
  if (sprintActive) {
    sprintNodeGroup.selectAll('.sprint-phase-node')
      .classed('highlighted', function() { return connectedIds.has(d3.select(this).attr('data-id')); })
      .classed('dimmed', function() { return !connectedIds.has(d3.select(this).attr('data-id')); });
    // Draw arc highlights showing which phases this node participates in
    drawPhaseArcs(d.id);
  }

  showDetailPanel(d);
}

function deselectAll() {
  selectedNode = null;
  node.classed('highlighted', false).classed('dimmed', false);
  link.classed('highlighted', false).classed('dimmed', false);
  spotlightGroup.selectAll('*').remove();
  clearPhaseArcs();
  if (sprintActive) {
    sprintNodeGroup.selectAll('.sprint-phase-node')
      .classed('highlighted', false).classed('dimmed', false);
  }
}

function showDetailPanel(d) {
  var panel = document.getElementById('detail-panel');
  var content = document.getElementById('panel-content');
  var color = TYPE_COLORS[d.type] || '#8b949e';

  // Find children and parents
  var children = [], parents = [];
  graphLinks.forEach(function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);

    if (l.type === 'part-of') return;

    // Overlap is symmetric; show in one "Overlaps" section regardless of edge direction.
    if (l.type === 'overlaps-with') {
      if (sid === d.id || tid === d.id) {
        var otherId = sid === d.id ? tid : sid;
        var otherNode = graphNodes.find(function(n) { return n.id === otherId; });
        if (otherNode) children.push(Object.assign({ edgeType: l.type, edgeMeta: l.meta || {} }, otherNode));
      }
      return;
    }

    if (sid === d.id) {
      var tn = graphNodes.find(function(n) { return n.id === tid; });
      if (tn) children.push(Object.assign({ edgeType: l.type, edgeMeta: l.meta || {} }, tn));
    }
    if (tid === d.id) {
      var sn = graphNodes.find(function(n) { return n.id === sid; });
      if (sn) parents.push(Object.assign({ edgeType: l.type, edgeMeta: l.meta || {} }, sn));
    }
  });

  // Build panel content using DOM methods (safe against injection)
  while (content.firstChild) content.removeChild(content.firstChild);

  var h2 = document.createElement('h2');
  h2.textContent = d.label;
  content.appendChild(h2);

  var badge = document.createElement('div');
  badge.className = 'type-badge';
  badge.style.cssText = 'background:' + color + '22;color:' + color + ';border:1px solid ' + color;
  badge.textContent = TYPE_LABELS[d.type];
  content.appendChild(badge);

  if (d.description) {
    var desc = document.createElement('div');
    desc.className = 'description';
    desc.textContent = d.description;
    content.appendChild(desc);
  }

  // Meta
  if (d.meta) {
    var metaFields = [
      ['Version', d.meta.version], ['Path', d.meta.path],
      ['Commands', d.meta.commandCount], ['Plugin', d.meta.plugin]
    ];
    metaFields.forEach(function(pair) {
      if (!pair[1]) return;
      var mi = document.createElement('div');
      mi.className = 'meta-item';
      mi.textContent = pair[0] + ': ';
      var sp = document.createElement('span');
      sp.textContent = pair[1];
      mi.appendChild(sp);
      content.appendChild(mi);
    });
  }

  // External links
  var links = [];
  if (d.meta && d.meta.repoUrl) {
    links.push({ label: 'GitHub repo', url: d.meta.repoUrl });
  }
  if (d.type === 'hook-event' && d.meta && d.meta.docsUrl) {
    links.push({ label: 'Claude Code hooks docs', url: d.meta.docsUrl });
  }
  if (links.length > 0) {
    var linksTitle = document.createElement('div');
    linksTitle.className = 'section-title';
    linksTitle.textContent = 'Links';
    content.appendChild(linksTitle);

    var linksList = document.createElement('ul');
    linksList.className = 'child-list';
    links.forEach(function(item) {
      var li = document.createElement('li');
      li.style.borderLeft = '2px solid ' + color;
      li.style.cursor = 'default';
      var a = document.createElement('a');
      a.href = item.url;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      a.textContent = item.label;
      a.onclick = function(event) { event.stopPropagation(); };
      li.appendChild(a);
      linksList.appendChild(li);
    });
    content.appendChild(linksList);
  }

  // Children grouped by edge type
  if (children.length > 0) {
    var grouped = {};
    children.forEach(function(c) {
      if (!grouped[c.edgeType]) grouped[c.edgeType] = [];
      grouped[c.edgeType].push(c);
    });

    var sectionLabels = {
      'provides-skill': 'Skills', 'provides-agent': 'Agents', 'provides-mcp': 'MCP Servers',
      'fires-hook': 'Hook Events', 'companion-of': 'Companions', 'depends-on': 'Dependencies',
      'overlaps-with': 'Overlaps'
    };

    Object.keys(grouped).forEach(function(edgeType) {
      var title = document.createElement('div');
      title.className = 'section-title';
      title.textContent = sectionLabels[edgeType] || edgeType;
      content.appendChild(title);

      var ul = document.createElement('ul');
      ul.className = 'child-list';
      grouped[edgeType].forEach(function(item) {
        var li = document.createElement('li');
        li.style.borderLeft = '2px solid ' + (TYPE_COLORS[item.type] || '#8b949e');
        li.textContent = item.label + ' ';
        var typeSpan = document.createElement('span');
        typeSpan.className = 'child-type';
        if (item.edgeType === 'overlaps-with') {
          var overlapScore = item.edgeMeta && typeof item.edgeMeta.score === 'number'
            ? item.edgeMeta.score.toFixed(2)
            : 'n/a';
          var overlapDomains = item.edgeMeta && Array.isArray(item.edgeMeta.domains) && item.edgeMeta.domains.length > 0
            ? ' [' + item.edgeMeta.domains.join(', ') + ']'
            : '';
          typeSpan.textContent = TYPE_LABELS[item.type] + ' · score ' + overlapScore + overlapDomains;
        } else {
          typeSpan.textContent = TYPE_LABELS[item.type];
        }
        li.appendChild(typeSpan);
        li.onclick = function() { navigateTo(item.id); };
        ul.appendChild(li);
      });
      content.appendChild(ul);
    });
  }

  // Parents
  if (parents.length > 0) {
    var pTitle = document.createElement('div');
    pTitle.className = 'section-title';
    pTitle.textContent = 'Provided by';
    content.appendChild(pTitle);

    var pUl = document.createElement('ul');
    pUl.className = 'child-list';
    parents.forEach(function(p) {
      var li = document.createElement('li');
      li.style.borderLeft = '2px solid ' + (TYPE_COLORS[p.type] || '#8b949e');
      li.textContent = p.label + ' ';
      var ts = document.createElement('span');
      ts.className = 'child-type';
      ts.textContent = TYPE_LABELS[p.type];
      li.appendChild(ts);
      li.onclick = function() { navigateTo(p.id); };
      pUl.appendChild(li);
    });
    content.appendChild(pUl);
  }

  // Sprint phases this node participates in (if sprint is active)
  if (sprintActive && nodeToPhases[d.id]) {
    var nodePhases = [];
    nodeToPhases[d.id].forEach(function(phaseId) {
      var phase = SPRINT_PHASES.find(function(p) { return p.id === phaseId; });
      if (phase) nodePhases.push(phase);
    });
    if (nodePhases.length > 0) {
      var spTitle = document.createElement('div');
      spTitle.className = 'section-title';
      spTitle.textContent = 'Sprint Phases';
      content.appendChild(spTitle);

      var spUl = document.createElement('ul');
      spUl.className = 'child-list';
      nodePhases.forEach(function(phase) {
        var phaseColor = PHASE_COLORS[phase.phase] || '#8b949e';
        var li = document.createElement('li');
        li.style.borderLeft = '2px solid ' + phaseColor;
        li.textContent = phase.step + '. ' + phase.label + ' ';
        var ts = document.createElement('span');
        ts.className = 'child-type';
        ts.textContent = phase.phase;
        li.appendChild(ts);
        li.style.cursor = 'pointer';
        li.onclick = (function(sprintNodeId) {
          return function() {
            var sn = nodeById[sprintNodeId];
            if (sn) selectSprintNode(sn);
          };
        })('sprint-' + phase.id);
        spUl.appendChild(li);
      });
      content.appendChild(spUl);
    }
  }

  panel.classList.add('open');
}

function closePanel() { document.getElementById('detail-panel').classList.remove('open'); }

function navigateTo(nodeId) {
  var targetNode = graphNodes.find(function(n) { return n.id === nodeId; });
  if (targetNode) {
    selectNode(targetNode);
    var transform = d3.zoomTransform(svg.node());
    var x = width / 2 - targetNode.x * transform.k;
    var y = height / 2 - targetNode.y * transform.k;
    svg.transition().duration(500).call(
      zoomBehavior.transform,
      d3.zoomIdentity.translate(x, y).scale(transform.k)
    );
  }
}

// Filters
function toggleFilter(type, btn) {
  if (activeFilters.has(type)) { activeFilters.delete(type); btn.classList.remove('active'); }
  else { activeFilters.add(type); btn.classList.add('active'); }
  applyFilters();
}

function showAll() {
  Object.keys(TYPE_COLORS).forEach(function(t) { activeFilters.add(t); });
  document.querySelectorAll('.filter-btn[data-type]').forEach(function(b) { b.classList.add('active'); });
  applyFilters();
}

function hideAll() {
  activeFilters.clear();
  document.querySelectorAll('.filter-btn[data-type]').forEach(function(b) { b.classList.remove('active'); });
  applyFilters();
}

function toggleDomain(domain, btn) {
  if (activeDomains.has(domain)) { activeDomains.delete(domain); btn.classList.remove('active'); }
  else { activeDomains.add(domain); btn.classList.add('active'); }
  updateHulls();
}

function showAllDomains() {
  domainNames.forEach(function(d) { activeDomains.add(d); });
  document.querySelectorAll('.filter-btn[data-domain]').forEach(function(b) { b.classList.add('active'); });
  updateHulls();
}

function hideAllDomains() {
  activeDomains.clear();
  document.querySelectorAll('.filter-btn[data-domain]').forEach(function(b) { b.classList.remove('active'); });
  updateHulls();
}

function toggleSidebar() {
  document.getElementById('filter-sidebar').classList.toggle('collapsed');
}

function applyFilters() {
  node.style('display', function(d) {
    if (!ecosystemActive) return 'none';
    if (!activeFilters.has(d.type)) return 'none';
    if (searchQuery && !d.label.toLowerCase().includes(searchQuery) && !d.id.toLowerCase().includes(searchQuery)) return 'none';
    return null;
  });
  link.style('display', function(l) {
    var sId = getNodeId(l.source);
    var tId = getNodeId(l.target);
    var sn = nodeById[sId];
    var tn = nodeById[tId];
    if (!sn || !tn) return 'none';
    // participates-in edges: visible when both endpoints are visible
    if (l.type === 'participates-in') {
      var phaseVisible = sn._sprint ? activePhases.has(sn._phase.id) : (tn._sprint ? activePhases.has(tn._phase.id) : true);
      var ecoNode = sn._sprint ? tn : sn;
      var ecoVisible = ecosystemActive && activeFilters.has(ecoNode.type);
      return (phaseVisible && ecoVisible && sprintActive) ? null : 'none';
    }
    // Regular ecosystem edges
    if (!ecosystemActive) return 'none';
    if (l.type === 'fires-hook' && !hooksVisible) return 'none';
    if (!activeFilters.has(sn.type) || !activeFilters.has(tn.type)) return 'none';
    return null;
  });
  // Sprint phase node visibility
  if (sprintActive) {
    sprintNodeGroup.selectAll('.sprint-phase-node').style('display', function() {
      var nodeId = d3.select(this).attr('data-id');
      var phaseId = nodeId.replace('sprint-', '');
      return activePhases.has(phaseId) ? null : 'none';
    });
  }
  updateHulls();
}

function onSearch(query) {
  searchQuery = query.toLowerCase().trim();
  applyFilters();
  if (searchQuery) {
    node.classed('highlighted', function(d) {
      return d.label.toLowerCase().includes(searchQuery) || d.id.toLowerCase().includes(searchQuery);
    });
    node.classed('dimmed', function(d) {
      return !(d.label.toLowerCase().includes(searchQuery) || d.id.toLowerCase().includes(searchQuery));
    });
  } else { deselectAll(); }
}

// Drag
function dragstarted(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x; d.fy = d.y;
}
function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
function dragended(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  d.fx = null; d.fy = null;
}

// Zoom to fit after layout settles
setTimeout(function() {
  var bounds = g.node().getBBox();
  var scale = 0.8 / Math.max(bounds.width / width, bounds.height / height);
  var midX = bounds.x + bounds.width / 2;
  var midY = bounds.y + bounds.height / 2;
  svg.transition().duration(750).call(
    zoomBehavior.transform,
    d3.zoomIdentity.translate(width / 2 - scale * midX, height / 2 - scale * midY).scale(scale)
  );
}, 2000);

// ═══════════════════════════════════════════════════════
// SPRINT PHASE DATA + TOGGLE LAYER SYSTEM
// ═══════════════════════════════════════════════════════

var SPRINT_PHASES = [
  {
    id: 'brainstorm', step: 1, label: 'Brainstorm',
    phase: 'ideation',
    command: 'bd create / /clavain brainstorm',
    description: 'Capture ideas freely. Explore the problem space, identify opportunities, and generate candidate solutions without filtering.',
    artifact: 'brainstorm doc',
    gate: null
  },
  {
    id: 'strategize', step: 2, label: 'Strategize',
    phase: 'ideation',
    command: '/clavain strategy',
    description: 'Structure brainstorm output into a PRD. Define features, create dependency graph, identify risks and tradeoffs.',
    artifact: 'PRD + feature beads',
    gate: null
  },
  {
    id: 'write-plan', step: 3, label: 'Write Plan',
    phase: 'planning',
    command: '/clavain write-plan',
    description: 'Break the strategy into bite-sized implementation tasks. Each task should be independently testable and mergeable.',
    artifact: 'implementation plan',
    gate: null
  },
  {
    id: 'review-plan', step: 4, label: 'Review Plan',
    phase: 'planning',
    command: '/clavain plan-review',
    description: 'Multi-agent review of the plan. Specialized agents check architecture, safety, correctness, and quality.',
    artifact: 'review verdict',
    gate: { type: 'soft', label: 'Plan approved' }
  },
  {
    id: 'execute', step: 5, label: 'Execute',
    phase: 'building',
    command: '/clavain execute-plan',
    description: 'Implement the plan in batches with review checkpoints. Each batch is a set of related tasks executed together.',
    artifact: 'code changes',
    gate: { type: 'hard', label: 'Plan exists' }
  },
  {
    id: 'test', step: 6, label: 'Test',
    phase: 'building',
    command: '/clavain tdd + /clavain verify',
    description: 'Run test suite, verify correctness. TDD for new code, verification before claiming completion.',
    artifact: 'test results',
    gate: null
  },
  {
    id: 'quality-gates', step: 7, label: 'Quality Gates',
    phase: 'quality',
    command: '/clavain quality-gates',
    description: 'Auto-select and run reviewer agents based on what changed. Architecture, safety, correctness, performance reviews.',
    artifact: 'review reports',
    gate: { type: 'hard', label: 'Tests pass' }
  },
  {
    id: 'resolve', step: 8, label: 'Resolve',
    phase: 'quality',
    command: '/clavain resolve',
    description: 'Address findings from quality gates. Fix issues, update code, re-run affected tests.',
    artifact: 'resolved findings',
    gate: null
  },
  {
    id: 'reflect', step: 9, label: 'Reflect',
    phase: 'learning',
    command: '/clavain reflect',
    description: 'Capture sprint learnings. What worked, what broke, what patterns to remember. Write to project memory.',
    artifact: 'learnings doc',
    gate: null
  },
  {
    id: 'ship', step: 10, label: 'Ship',
    phase: 'shipping',
    command: '/clavain land',
    description: 'Final landing workflow. Push to trunk, close beads, sync, verify deployment.',
    artifact: 'merged PR / pushed commits',
    gate: { type: 'soft', label: 'Findings resolved' }
  }
];

var PHASE_COLORS = {
  'ideation': '#F39C12',
  'planning': '#3498DB',
  'building': '#2ECC71',
  'quality': '#E74C3C',
  'learning': '#9B59B6',
  'shipping': '#1ABC9C'
};

// Curated mapping: which ecosystem nodes participate in each sprint phase
var PHASE_PLUGINS = {
  'brainstorm':     ['clavain'],
  'strategize':     ['clavain', 'interpath'],
  'write-plan':     ['clavain', 'interpath'],
  'review-plan':    ['clavain', 'interflux', 'interpeer'],
  'execute':        ['clavain', 'intertest', 'interlock', 'interdev'],
  'test':           ['clavain', 'intertest'],
  'quality-gates':  ['clavain', 'interflux', 'intercheck', 'interpeer'],
  'resolve':        ['clavain', 'interflux'],
  'reflect':        ['clavain', 'interdoc', 'interfluence'],
  'ship':           ['clavain', 'interlock']
};

// Fine-grained: which specific skills/agents/MCP servers each phase uses (tier 2 — on-demand spotlight, NOT force links)
var PHASE_SKILLS = {
  'brainstorm':    { skills: ['clavain:brainstorming'], agents: [], mcp: [] },
  'strategize':    { skills: ['clavain:writing-plans'], agents: [], mcp: [] },
  'write-plan':    { skills: ['clavain:writing-plans'], agents: [], mcp: [] },
  'review-plan':   { skills: ['interflux:flux-drive', 'interpeer:interpeer'],
                     agents: ['interflux:agent:fd-architecture', 'interflux:agent:fd-safety',
                              'interflux:agent:fd-correctness', 'interflux:agent:fd-user-product',
                              'interflux:agent:fd-quality', 'intersynth:agent:synthesize-review'],
                     mcp: [] },
  'execute':       { skills: ['clavain:executing-plans', 'interdev:working-with-claude-code',
                              'intertest:test-driven-development'], agents: [], mcp: [] },
  'test':          { skills: ['intertest:test-driven-development', 'intertest:verification-before-completion',
                              'intertest:systematic-debugging'], agents: [], mcp: [] },
  'quality-gates': { skills: ['interflux:flux-drive', 'intercheck:status', 'interpeer:interpeer'],
                     agents: ['interflux:agent:fd-architecture', 'interflux:agent:fd-safety',
                              'interflux:agent:fd-correctness', 'interflux:agent:fd-user-product',
                              'interflux:agent:fd-quality', 'intersynth:agent:synthesize-review',
                              'intercraft:agent:agent-native-reviewer'],
                     mcp: [] },
  'resolve':       { skills: ['interflux:flux-drive', 'clavain:code-review-discipline'], agents: [], mcp: [] },
  'reflect':       { skills: ['interdoc:interdoc', 'clavain:engineering-docs'],
                     agents: ['interfluence:agent:voice-analyzer'], mcp: [] },
  'ship':          { skills: ['clavain:landing-a-change'], agents: [], mcp: [] }
};

// Reverse lookup: nodeId -> [phaseId, ...] (from both PHASE_PLUGINS and PHASE_SKILLS)
var nodeToPhases = {};
function addNodePhase(nodeId, phaseId) {
  if (!nodeToPhases[nodeId]) nodeToPhases[nodeId] = [];
  if (nodeToPhases[nodeId].indexOf(phaseId) === -1) nodeToPhases[nodeId].push(phaseId);
}
Object.keys(PHASE_PLUGINS).forEach(function(phaseId) {
  PHASE_PLUGINS[phaseId].forEach(function(pid) { addNodePhase(pid, phaseId); });
});
Object.keys(PHASE_SKILLS).forEach(function(phaseId) {
  var entry = PHASE_SKILLS[phaseId];
  entry.skills.forEach(function(sid) { addNodePhase(sid, phaseId); });
  entry.agents.forEach(function(aid) { addNodePhase(aid, phaseId); });
  entry.mcp.forEach(function(mid) { addNodePhase(mid, phaseId); });
});

// Toggle state
var ecosystemActive = true;
var sprintActive = false;
var activePhases = new Set(SPRINT_PHASES.map(function(p) { return p.id; }));

// Sprint phase nodes and edges that get injected into the simulation
var sprintNodes = [];
var sprintLinks = [];

// SVG layers for sprint-specific rendering
var sprintFlowGroup = g.append('g').attr('class', 'sprint-flow-layer');
var phaseArcGroup = g.append('g').attr('class', 'phase-arc-layer');
var sprintNodeGroup = g.append('g').attr('class', 'sprint-node-layer');
var spotlightGroup = g.append('g').attr('class', 'spotlight-layer');

// ── Phase arc highlights — show which sprint phases a plugin participates in ──

function clearPhaseArcs() { phaseArcGroup.selectAll('*').remove(); }

function drawPhaseArcs(nodeId) {
  clearPhaseArcs();
  if (!sprintActive || !nodeToPhases[nodeId]) return;

  var phases = nodeToPhases[nodeId];
  // Map phase IDs to their indices in SPRINT_PHASES
  var indices = [];
  phases.forEach(function(pid) {
    var idx = SPRINT_PHASES.findIndex(function(p) { return p.id === pid; });
    if (idx >= 0 && activePhases.has(pid)) indices.push(idx);
  });
  if (indices.length === 0) return;
  indices.sort(function(a, b) { return a - b; });

  // Find contiguous spans
  var spans = [];
  var spanStart = indices[0], spanEnd = indices[0];
  for (var i = 1; i < indices.length; i++) {
    if (indices[i] === spanEnd + 1) {
      spanEnd = indices[i];
    } else {
      spans.push([spanStart, spanEnd]);
      spanStart = spanEnd = indices[i];
    }
  }
  spans.push([spanStart, spanEnd]);

  // Get the plugin node color for the arc
  var pluginNode = nodeById[nodeId];
  var arcColor = pluginNode ? (TYPE_COLORS[pluginNode.type] || '#58a6ff') : '#58a6ff';

  // Draw each span as an SVG elliptical arc
  var n = SPRINT_PHASES.length;
  var cx = width * 0.5, cy = height * 0.5;
  // Arc sits slightly outside the sprint ring
  var arcRx = width * 0.40 + 20;
  var arcRy = height * 0.40 + 20;

  spans.forEach(function(span) {
    var startIdx = span[0], endIdx = span[1];
    if (startIdx === endIdx) {
      // Single phase: draw a dot instead of an arc
      var angle = -Math.PI / 2 + (startIdx / n) * 2 * Math.PI;
      phaseArcGroup.append('circle')
        .attr('class', 'phase-arc-dot')
        .attr('cx', cx + arcRx * Math.cos(angle))
        .attr('cy', cy + arcRy * Math.sin(angle))
        .attr('r', 6)
        .attr('fill', arcColor)
        .style('--arc-color', arcColor)
        .attr('opacity', 0)
        .transition().duration(300).attr('opacity', 0.7);
      return;
    }

    // Multi-phase arc: draw along the ellipse
    var startAngle = -Math.PI / 2 + (startIdx / n) * 2 * Math.PI;
    var endAngle = -Math.PI / 2 + (endIdx / n) * 2 * Math.PI;

    // Build arc path using elliptical arc command
    var x1 = cx + arcRx * Math.cos(startAngle);
    var y1 = cy + arcRy * Math.sin(startAngle);
    var x2 = cx + arcRx * Math.cos(endAngle);
    var y2 = cy + arcRy * Math.sin(endAngle);

    // Large arc flag: if span covers more than half the circle
    var angleDiff = endAngle - startAngle;
    var largeArc = angleDiff > Math.PI ? 1 : 0;

    phaseArcGroup.append('path')
      .attr('class', 'phase-arc')
      .attr('d', 'M' + x1 + ',' + y1 +
        ' A' + arcRx + ',' + arcRy + ' 0 ' + largeArc + ',1 ' + x2 + ',' + y2)
      .attr('stroke', arcColor)
      .style('--arc-color', arcColor)
      .attr('stroke-opacity', 0)
      .transition().duration(300).attr('stroke-opacity', 0.5);
  });
}

// Compute pinned positions for sprint phases — elliptical ring around ecosystem
function computePhasePositions() {
  var positions = [];
  var cx = width * 0.5;
  var cy = height * 0.5;
  var rx = width * 0.40;
  var ry = height * 0.40;
  // 10 phases clockwise from top (12 o'clock): Brainstorm at top
  var n = SPRINT_PHASES.length;
  for (var i = 0; i < n; i++) {
    var angle = -Math.PI / 2 + (i / n) * 2 * Math.PI; // start at -π/2 (top), go clockwise
    positions.push({ x: cx + rx * Math.cos(angle), y: cy + ry * Math.sin(angle) });
  }
  return positions;
}

var phasePositions = computePhasePositions();

// Build sprint phase filter buttons in sidebar
var phaseList = document.getElementById('phase-list');
SPRINT_PHASES.forEach(function(phase) {
  var color = PHASE_COLORS[phase.phase] || '#8b949e';
  var btn = document.createElement('button');
  btn.className = 'filter-btn active';
  btn.style.setProperty('--type-color', color);
  var dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  btn.appendChild(document.createTextNode(phase.step + '. ' + phase.label));
  btn.dataset.phase = phase.id;
  btn.onclick = function() { togglePhase(phase.id, btn); };
  phaseList.appendChild(btn);
});

function togglePhase(phaseId, btn) {
  if (activePhases.has(phaseId)) { activePhases.delete(phaseId); btn.classList.remove('active'); }
  else { activePhases.add(phaseId); btn.classList.add('active'); }
  if (sprintActive) rebuildSprintLayer();
}

function showAllPhases() {
  SPRINT_PHASES.forEach(function(p) { activePhases.add(p.id); });
  document.querySelectorAll('.filter-btn[data-phase]').forEach(function(b) { b.classList.add('active'); });
  if (sprintActive) rebuildSprintLayer();
}

function hideAllPhases() {
  activePhases.clear();
  document.querySelectorAll('.filter-btn[data-phase]').forEach(function(b) { b.classList.remove('active'); });
  if (sprintActive) rebuildSprintLayer();
}

// Arrow markers for sprint flow (append to main SVG defs)
var defs = svg.append('defs');
defs.append('marker')
  .attr('id', 'sprint-arrow')
  .attr('viewBox', '0 0 10 6')
  .attr('refX', 10).attr('refY', 3)
  .attr('markerWidth', 10).attr('markerHeight', 6)
  .attr('orient', 'auto')
  .append('path')
  .attr('d', 'M0,0 L10,3 L0,6 Z')
  .attr('fill', '#58a6ff');

defs.append('marker')
  .attr('id', 'sprint-skip-arrow')
  .attr('viewBox', '0 0 10 6')
  .attr('refX', 10).attr('refY', 3)
  .attr('markerWidth', 10).attr('markerHeight', 6)
  .attr('orient', 'auto')
  .append('path')
  .attr('d', 'M0,0 L10,3 L0,6 Z')
  .attr('fill', '#F39C12');

// ── Toggle layer function ──

function toggleLayer(layerName) {
  var btn = document.getElementById('toggle-' + layerName);

  if (layerName === 'ecosystem') {
    ecosystemActive = !ecosystemActive;
    btn.classList.toggle('active', ecosystemActive);
  } else if (layerName === 'sprint') {
    sprintActive = !sprintActive;
    btn.classList.toggle('active', sprintActive);
  }

  // Show/hide ecosystem-specific UI
  var sidebarToggle = document.getElementById('sidebar-toggle');
  var searchBox = document.getElementById('search-box');
  var statsEl = document.getElementById('stats');
  sidebarToggle.style.display = ecosystemActive ? '' : 'none';
  searchBox.style.display = ecosystemActive ? '' : 'none';
  statsEl.style.display = ecosystemActive ? '' : 'none';

  // Show/hide sprint phase filter section in sidebar
  document.getElementById('phase-filter-section').style.display = sprintActive ? '' : 'none';

  // If nothing is active, do nothing special — just empty graph
  rebuildGraph();
}

var hooksVisible = false;
function toggleHookEdges() {
  hooksVisible = !hooksVisible;
  var btn = document.getElementById('toggle-hooks');
  btn.classList.toggle('active', hooksVisible);
  btn.style.opacity = hooksVisible ? '1' : '0.6';
  applyFilters();
}

function rebuildGraph() {
  // Clear sprint-specific rendering + spotlight
  sprintNodeGroup.selectAll('*').remove();
  sprintFlowGroup.selectAll('*').remove();
  spotlightGroup.selectAll('*').remove();

  // Dim domain hulls when sprint is active to reduce visual noise
  hullGroup.classed('hulls-dimmed', sprintActive);
  hullLabelGroup.classed('hulls-dimmed', sprintActive);

  // Remove old sprint nodes and links from arrays
  for (var i = graphNodes.length - 1; i >= 0; i--) {
    if (graphNodes[i]._sprint) graphNodes.splice(i, 1);
  }
  for (var i = graphLinks.length - 1; i >= 0; i--) {
    if (graphLinks[i]._sprint) graphLinks.splice(i, 1);
  }

  // Clean up nodeById for removed sprint nodes
  SPRINT_PHASES.forEach(function(p) {
    delete nodeById['sprint-' + p.id];
  });

  sprintNodes = [];
  sprintLinks = [];

  // Inject sprint nodes if sprint is active
  if (sprintActive) {
    buildSprintNodes();
  }

  // Rebuild D3 selections
  rebuildSimulation();

  // Draw sprint flow arrows (static decorative layer)
  if (sprintActive) {
    drawSprintFlowArrows();
    renderSprintNodes();
  }

  // Apply visibility
  applyFilters();
}

function buildSprintNodes() {
  SPRINT_PHASES.forEach(function(phase, idx) {
    if (!activePhases.has(phase.id)) return;

    var pos = phasePositions[idx];
    var nodeId = 'sprint-' + phase.id;
    var sprintNode = {
      id: nodeId,
      label: phase.label,
      type: 'sprint-phase',
      description: phase.description,
      _sprint: true,
      _phase: phase,
      fx: pos.x,
      fy: pos.y,
      x: pos.x,
      y: pos.y
    };
    sprintNodes.push(sprintNode);
    graphNodes.push(sprintNode);
    nodeById[nodeId] = sprintNode;

    // Create participates-in edges to ecosystem nodes (only if ecosystem is active)
    if (ecosystemActive && PHASE_PLUGINS[phase.id]) {
      PHASE_PLUGINS[phase.id].forEach(function(pluginId) {
        if (nodeById[pluginId]) {
          var link = {
            source: nodeId,
            target: pluginId,
            type: 'participates-in',
            _sprint: true
          };
          sprintLinks.push(link);
          graphLinks.push(link);
        }
      });
    }
  });
}

function rebuildSimulation() {
  // Rebuild link selection
  link = linkGroup.selectAll('line').data(graphLinks, function(d) {
    return (typeof d.source === 'object' ? d.source.id : d.source) + '-' +
           (typeof d.target === 'object' ? d.target.id : d.target) + '-' + d.type;
  });
  link.exit().remove();
  link = link.enter().append('line')
    .attr('class', function(d) { return 'link ' + d.type; })
    .attr('stroke-width', function(d) { return d.type === 'companion-of' ? 2 : 1; })
    .merge(link);

  // Rebuild node selection (ecosystem nodes only — sprint phase nodes rendered separately)
  node = nodeGroup_eco.selectAll('g.node').data(
    graphNodes.filter(function(n) { return !n._sprint; }),
    function(d) { return d.id; }
  );
  node.exit().remove();
  var nodeEnter = node.enter().append('g')
    .attr('class', function(d) { return 'node' + (CORE_TYPES[d.type] ? '' : ' leaf-node'); })
    .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));
  nodeEnter.append('circle')
    .attr('r', function(d) { return TYPE_SIZES[d.type] || 8; })
    .attr('fill', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
    .style('--glow', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
    .on('click', function(event, d) { event.stopPropagation(); selectNode(d); });
  nodeEnter.append('text')
    .attr('dx', function(d) { return (TYPE_SIZES[d.type] || 8) + 4; })
    .attr('dy', 3)
    .text(function(d) { return d.label; })
    .style('font-size', function(d) {
      if (d.type === 'monorepo' || d.type === 'hub') return '13px';
      if (d.type === 'plugin' || d.type === 'kernel' || d.type === 'service') return '11px';
      return '9px';
    });
  node = nodeEnter.merge(node);

  // Update simulation
  simulation.nodes(graphNodes);
  simulation.force('link').links(graphLinks);
  simulation.alpha(0.3).restart();
}

function renderSprintNodes() {
  var nodeW = 160, nodeH = 56;

  sprintNodes.forEach(function(sn) {
    var phase = sn._phase;
    var color = PHASE_COLORS[phase.phase] || '#8b949e';

    var gNode = sprintNodeGroup.append('g')
      .attr('class', 'sprint-phase-node')
      .attr('data-id', sn.id)
      .attr('transform', 'translate(' + (sn.x - nodeW / 2) + ',' + (sn.y - nodeH / 2) + ')')
      .style('cursor', 'grab')
      .on('click', function(event) {
        event.stopPropagation();
        selectSprintNode(sn);
      })
      .call(d3.drag()
        .on('start', function(event) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          sn.fx = sn.x; sn.fy = sn.y;
          d3.select(this).style('cursor', 'grabbing');
        })
        .on('drag', function(event) {
          sn.fx = event.x; sn.fy = event.y;
          sn.x = event.x; sn.y = event.y;
        })
        .on('end', function(event) {
          if (!event.active) simulation.alphaTarget(0);
          // Keep pinned where user dropped it (don't clear fx/fy)
          d3.select(this).style('cursor', 'grab');
        })
      );

    // Background rect
    gNode.append('rect')
      .attr('width', nodeW).attr('height', nodeH)
      .attr('rx', 8).attr('ry', 8)
      .attr('fill', '#161b22')
      .attr('stroke', color).attr('stroke-width', 2);

    // Step number circle
    gNode.append('circle')
      .attr('cx', 20).attr('cy', 20).attr('r', 12)
      .attr('fill', color).attr('opacity', 0.2);
    gNode.append('text')
      .attr('x', 20).attr('y', 24)
      .attr('text-anchor', 'middle')
      .attr('fill', color).attr('font-size', '12px').attr('font-weight', '700')
      .text(phase.step);

    // Label
    gNode.append('text')
      .attr('x', 40).attr('y', 24)
      .attr('fill', '#f0f6fc').attr('font-size', '13px').attr('font-weight', '600')
      .text(phase.label);

    // Phase name + artifact
    gNode.append('text')
      .attr('x', 12).attr('y', 46)
      .attr('fill', color).attr('font-size', '9px').attr('opacity', 0.7)
      .text(phase.phase);

    gNode.append('text')
      .attr('x', nodeW - 8).attr('y', 46)
      .attr('text-anchor', 'end')
      .attr('fill', '#8b949e').attr('font-size', '8px')
      .text(phase.artifact);
  });
}

function drawSprintFlowArrows() {
  var nodeW = 160, nodeH = 56;

  // Get active sprint node positions
  var activeSprintNodes = sprintNodes.filter(function(sn) {
    return activePhases.has(sn._phase.id);
  });

  // Build position lookup
  var posById = {};
  activeSprintNodes.forEach(function(sn) {
    posById[sn._phase.id] = { x: sn.x, y: sn.y };
  });

  // Draw flow arrows between consecutive active phases
  for (var i = 0; i < SPRINT_PHASES.length - 1; i++) {
    var fromPhase = SPRINT_PHASES[i];
    var toPhase = SPRINT_PHASES[i + 1];
    var from = posById[fromPhase.id];
    var to = posById[toPhase.id];
    if (!from || !to) continue;

    // Calculate direction
    var dx = to.x - from.x;
    var dy = to.y - from.y;
    var dist = Math.sqrt(dx * dx + dy * dy) || 1;
    var nx = dx / dist;
    var ny = dy / dist;

    // Start from edge of source, end at edge of target
    var sx = from.x + nx * (nodeW / 2 + 4);
    var sy = from.y + ny * (nodeH / 2 + 4);
    var ex = to.x - nx * (nodeW / 2 + 4);
    var ey = to.y - ny * (nodeH / 2 + 4);

    sprintFlowGroup.append('line')
      .attr('class', 'sprint-flow-arrow')
      .attr('x1', sx).attr('y1', sy)
      .attr('x2', ex).attr('y2', ey)
      .attr('stroke', '#58a6ff').attr('stroke-width', 2)
      .attr('marker-end', 'url(#sprint-arrow)');

    // Draw gate diamond if the target has a gate
    if (toPhase.gate) {
      var gateColor = toPhase.gate.type === 'hard' ? '#E74C3C' : '#F39C12';
      var gx = (sx + ex) / 2;
      var gy = (sy + ey) / 2;
      var ds = 8;
      sprintFlowGroup.append('path')
        .attr('class', 'gate-diamond')
        .attr('d', 'M' + gx + ',' + (gy - ds) +
          ' L' + (gx + ds) + ',' + gy +
          ' L' + gx + ',' + (gy + ds) +
          ' L' + (gx - ds) + ',' + gy + ' Z')
        .attr('fill', gateColor).attr('stroke', gateColor).attr('stroke-width', 1)
        .attr('opacity', 0.9);

      sprintFlowGroup.append('text')
        .attr('x', gx).attr('y', gy - ds - 5)
        .attr('text-anchor', 'middle')
        .attr('fill', gateColor).attr('font-size', '9px')
        .text(toPhase.gate.label);
    }
  }

  // Skip path: Brainstorm → Write Plan (curves inward toward center)
  var skipFrom = posById['brainstorm'];
  var skipTo = posById['write-plan'];
  if (skipFrom && skipTo) {
    var skipMidX = (skipFrom.x + skipTo.x) / 2 + (width * 0.5 - (skipFrom.x + skipTo.x) / 2) * 0.5;
    var skipMidY = (skipFrom.y + skipTo.y) / 2 + (height * 0.5 - (skipFrom.y + skipTo.y) / 2) * 0.5;
    sprintFlowGroup.append('path')
      .attr('class', 'sprint-flow-arrow')
      .attr('d', 'M' + skipFrom.x + ',' + skipFrom.y +
        ' Q' + skipMidX + ',' + skipMidY +
        ' ' + skipTo.x + ',' + skipTo.y)
      .attr('fill', 'none').attr('stroke', '#F39C12').attr('stroke-width', 2)
      .attr('stroke-dasharray', '6 3')
      .attr('marker-end', 'url(#sprint-skip-arrow)');

    sprintFlowGroup.append('text')
      .attr('x', skipMidX).attr('y', skipMidY - 10)
      .attr('text-anchor', 'middle')
      .attr('fill', '#F39C12').attr('font-size', '10px')
      .text('skip (trivial tasks)');
  }
}

function rebuildSprintLayer() {
  rebuildGraph();
}

// ── Spotlight layer — on-demand bezier curves for tier-2 connections ──

function drawSpotlightConnections(sourceNode, targetIds) {
  spotlightGroup.selectAll('*').remove();
  targetIds.forEach(function(tid) {
    var targetNode = nodeById[tid];
    if (!targetNode) return;
    var sx = sourceNode.x, sy = sourceNode.y;
    var tx = targetNode.x, ty = targetNode.y;
    var mx = (sx + tx) / 2;
    var my = (sy + ty) / 2 - 40; // curve upward
    spotlightGroup.append('path')
      .attr('d', 'M' + sx + ',' + sy + ' Q' + mx + ',' + my + ' ' + tx + ',' + ty)
      .attr('fill', 'none')
      .attr('stroke', '#45B7D1')
      .attr('stroke-width', 1.5)
      .attr('stroke-dasharray', '6 3')
      .attr('stroke-opacity', 0)
      .attr('data-source', sourceNode.id)
      .attr('data-target', tid)
      .transition().duration(300)
      .attr('stroke-opacity', 0.7);
  });
}

function updateSpotlightPaths() {
  var paths = spotlightGroup.selectAll('path');
  if (paths.empty()) return;
  paths.each(function() {
    var el = d3.select(this);
    var sid = el.attr('data-source');
    var tid = el.attr('data-target');
    var sn = nodeById[sid];
    var tn = nodeById[tid];
    if (!sn || !tn) return;
    var mx = (sn.x + tn.x) / 2;
    var my = (sn.y + tn.y) / 2 - 40;
    el.attr('d', 'M' + sn.x + ',' + sn.y + ' Q' + mx + ',' + my + ' ' + tn.x + ',' + tn.y);
  });
}

// ── Sprint node interactions ──

function selectSprintNode(sn) {
  var phase = sn._phase;
  var connectedIds = new Set([sn.id]);
  var spotlightTargets = [];

  // Find participating ecosystem nodes (tier 1 — force links)
  if (ecosystemActive && PHASE_PLUGINS[phase.id]) {
    PHASE_PLUGINS[phase.id].forEach(function(pid) {
      if (nodeById[pid]) connectedIds.add(pid);
    });
  }

  // Find tier-2 skill/agent/MCP nodes (spotlight, not force links)
  if (ecosystemActive && PHASE_SKILLS[phase.id]) {
    var entry = PHASE_SKILLS[phase.id];
    entry.skills.concat(entry.agents).concat(entry.mcp).forEach(function(id) {
      if (nodeById[id]) {
        connectedIds.add(id);
        spotlightTargets.push(id);
      }
    });
  }

  // Also connect to adjacent sprint phases
  var idx = SPRINT_PHASES.indexOf(phase);
  if (idx > 0) connectedIds.add('sprint-' + SPRINT_PHASES[idx - 1].id);
  if (idx < SPRINT_PHASES.length - 1) connectedIds.add('sprint-' + SPRINT_PHASES[idx + 1].id);

  // Highlight/dim ecosystem nodes
  node.classed('highlighted', function(n) { return connectedIds.has(n.id); });
  node.classed('dimmed', function(n) { return !connectedIds.has(n.id); });

  // Highlight edges: light up participates-in edges AND provides-skill/provides-agent edges
  // between highlighted plugins and their highlighted children
  link.classed('highlighted', function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);
    return connectedIds.has(sid) && connectedIds.has(tid);
  });
  link.classed('dimmed', function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);
    return !(connectedIds.has(sid) && connectedIds.has(tid));
  });

  // Highlight/dim sprint phase nodes
  sprintNodeGroup.selectAll('.sprint-phase-node')
    .classed('highlighted', function() { return connectedIds.has(d3.select(this).attr('data-id')); })
    .classed('dimmed', function() { return !connectedIds.has(d3.select(this).attr('data-id')); });

  // Draw spotlight bezier curves to tier-2 nodes
  if (spotlightTargets.length > 0) {
    drawSpotlightConnections(sn, spotlightTargets);
  } else {
    spotlightGroup.selectAll('*').remove();
  }

  showSprintDetail(phase);
}

function showSprintDetail(phase) {
  var panel = document.getElementById('detail-panel');
  var content = document.getElementById('panel-content');
  var color = PHASE_COLORS[phase.phase] || '#8b949e';

  while (content.firstChild) content.removeChild(content.firstChild);

  // Step header
  var h2 = document.createElement('h2');
  h2.textContent = 'Step ' + phase.step + ': ' + phase.label;
  content.appendChild(h2);

  // Phase badge
  var badge = document.createElement('div');
  badge.className = 'type-badge';
  badge.style.cssText = 'background:' + color + '22;color:' + color + ';border:1px solid ' + color;
  badge.textContent = phase.phase;
  content.appendChild(badge);

  // Description
  var desc = document.createElement('div');
  desc.className = 'description';
  desc.textContent = phase.description;
  content.appendChild(desc);

  // Command
  var cmdTitle = document.createElement('div');
  cmdTitle.className = 'section-title';
  cmdTitle.textContent = 'Command';
  content.appendChild(cmdTitle);

  var cmdBox = document.createElement('div');
  cmdBox.style.cssText = 'background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px 12px;font-family:monospace;font-size:12px;color:#50C878;margin-bottom:12px;';
  cmdBox.textContent = phase.command;
  content.appendChild(cmdBox);

  // Artifact
  var artTitle = document.createElement('div');
  artTitle.className = 'section-title';
  artTitle.textContent = 'Artifact';
  content.appendChild(artTitle);

  var artItem = document.createElement('div');
  artItem.className = 'meta-item';
  var artSpan = document.createElement('span');
  artSpan.textContent = phase.artifact;
  artItem.appendChild(artSpan);
  content.appendChild(artItem);

  // Gate
  if (phase.gate) {
    var gateTitle = document.createElement('div');
    gateTitle.className = 'section-title';
    gateTitle.textContent = 'Gate';
    content.appendChild(gateTitle);

    var gateColor = phase.gate.type === 'hard' ? '#E74C3C' : '#F39C12';
    var gateBadge = document.createElement('div');
    gateBadge.className = 'type-badge';
    gateBadge.style.cssText = 'background:' + gateColor + '22;color:' + gateColor + ';border:1px solid ' + gateColor;
    gateBadge.textContent = phase.gate.type.toUpperCase() + ' \u2014 ' + phase.gate.label;
    content.appendChild(gateBadge);

    var gateDesc = document.createElement('div');
    gateDesc.className = 'description';
    gateDesc.textContent = phase.gate.type === 'hard'
      ? 'This gate blocks progress. The condition must be met before proceeding.'
      : 'This gate is advisory. It can be bypassed but doing so is flagged.';
    content.appendChild(gateDesc);
  }

  // Orchestrating plugins (tier 1 — force-linked)
  if (PHASE_PLUGINS[phase.id] && PHASE_PLUGINS[phase.id].length > 0) {
    var plugTitle = document.createElement('div');
    plugTitle.className = 'section-title';
    plugTitle.textContent = 'Orchestrating Plugins';
    content.appendChild(plugTitle);

    var plugUl = document.createElement('ul');
    plugUl.className = 'child-list';
    PHASE_PLUGINS[phase.id].forEach(function(pid) {
      var pNode = nodeById[pid];
      if (!pNode) return;
      var li = document.createElement('li');
      li.style.borderLeft = '2px solid ' + (TYPE_COLORS[pNode.type] || '#8b949e');
      li.textContent = pNode.label + ' ';
      var ts = document.createElement('span');
      ts.className = 'child-type';
      ts.textContent = TYPE_LABELS[pNode.type] || pNode.type;
      li.appendChild(ts);
      li.onclick = function() { navigateTo(pid); };
      plugUl.appendChild(li);
    });
    content.appendChild(plugUl);
  }

  // Tier-2 fine-grained connections (skills, agents, MCP servers)
  if (PHASE_SKILLS[phase.id]) {
    var entry = PHASE_SKILLS[phase.id];
    var sections = [
      { label: 'Skills', ids: entry.skills, color: TYPE_COLORS['skill'] },
      { label: 'Agents', ids: entry.agents, color: TYPE_COLORS['agent'] },
      { label: 'MCP Servers', ids: entry.mcp, color: TYPE_COLORS['mcp-server'] }
    ];
    sections.forEach(function(sec) {
      if (sec.ids.length === 0) return;
      var secTitle = document.createElement('div');
      secTitle.className = 'section-title';
      secTitle.textContent = sec.label;
      content.appendChild(secTitle);

      var secUl = document.createElement('ul');
      secUl.className = 'child-list';
      sec.ids.forEach(function(nid) {
        var sNode = nodeById[nid];
        var li = document.createElement('li');
        li.style.borderLeft = '2px solid ' + sec.color;
        if (sNode) {
          li.textContent = sNode.label + ' ';
          var ts = document.createElement('span');
          ts.className = 'child-type';
          ts.textContent = TYPE_LABELS[sNode.type] || sNode.type;
          li.appendChild(ts);
          li.onclick = function() { navigateTo(nid); };
        } else {
          li.textContent = nid;
          li.style.opacity = '0.5';
        }
        secUl.appendChild(li);
      });
      content.appendChild(secUl);
    });
  }

  panel.classList.add('open');
}
</script>
</body>
</html>
