<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Interverse Ecosystem</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #0d1117;
  color: #c9d1d9;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
}

#toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
  background: #161b22;
  border-bottom: 1px solid #30363d;
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  height: 44px;
}

#toolbar .title {
  font-weight: 600;
  font-size: 14px;
  color: #f0f6fc;
  white-space: nowrap;
}

#toolbar .stats {
  font-size: 11px;
  color: #8b949e;
  white-space: nowrap;
}

#filter-sidebar {
  position: fixed;
  top: 44px;
  left: 0;
  width: 180px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-right: 1px solid #30363d;
  z-index: 90;
  overflow-y: auto;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

#filter-sidebar .sidebar-title {
  font-size: 11px;
  font-weight: 600;
  color: #8b949e;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 4px;
}

#filter-sidebar .meta-row {
  display: flex;
  gap: 4px;
  margin-bottom: 8px;
}

#filter-list, #domain-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  border-top: 1px solid #30363d;
  padding-top: 8px;
}

.filter-btn {
  border: 1px solid #30363d;
  background: transparent;
  color: #8b949e;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
  width: 100%;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 6px;
}

.filter-btn .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}

.filter-btn.active {
  border-color: var(--type-color);
  color: var(--type-color);
  background: color-mix(in srgb, var(--type-color) 12%, transparent);
}

.filter-btn:hover { border-color: #58a6ff; }

.filter-btn.meta {
  font-weight: 600;
  border-color: #58a6ff;
  color: #58a6ff;
  width: 100%;
  flex: 0 0 auto;
  text-align: left;
  justify-content: flex-start;
  padding: 3px 8px;
  font-size: 10px;
}

#filter-sidebar .meta-row .filter-btn.meta {
  width: auto;
  flex: 1;
  text-align: center;
  justify-content: center;
  font-size: 11px;
  padding: 4px 10px;
}

.filter-btn.meta:hover { background: rgba(88, 166, 255, 0.1); }

#search-box {
  border: 1px solid #30363d; background: #0d1117; color: #c9d1d9;
  padding: 4px 10px; border-radius: 6px; font-size: 12px;
  width: 160px; margin-left: auto;
}
#search-box:focus { outline: none; border-color: #58a6ff; }

#graph { width: 100vw; height: 100vh; padding-top: 44px; padding-left: 180px; }
#graph svg { width: 100%; height: 100%; }

.node circle { cursor: pointer; transition: opacity 0.2s; }
.node circle:hover { filter: brightness(1.3); }
.node text { font-size: 10px; fill: #8b949e; pointer-events: none; user-select: none; }

.link { stroke-opacity: 0.3; transition: stroke-opacity 0.2s; }
.link.provides-skill { stroke: #50C878; }
.link.provides-agent { stroke: #FF8C42; }
.link.provides-mcp { stroke: #9B59B6; stroke-dasharray: 4 2; }
.link.fires-hook { stroke: #E74C3C; stroke-dasharray: 2 2; }
.link.companion-of { stroke: #F39C12; stroke-dasharray: 6 3; stroke-width: 2; }
.link.depends-on { stroke: #1ABC9C; stroke-dasharray: 4 4; }
.link.part-of { stroke: #30363d; }

.domain-hull {
  fill-opacity: 0.08;
  stroke-opacity: 0.35;
  stroke-width: 1.5;
  stroke-dasharray: 6 3;
  pointer-events: none;
  transition: fill-opacity 0.3s, stroke-opacity 0.3s;
}
.domain-hull:hover { fill-opacity: 0.14; stroke-opacity: 0.5; }
.domain-hull.hidden { fill-opacity: 0; stroke-opacity: 0; }

.domain-label {
  font-size: 9px;
  font-weight: 600;
  fill-opacity: 0.4;
  pointer-events: none;
  text-anchor: middle;
}

.dimmed circle { opacity: 0.1; }
.dimmed text { opacity: 0.1; }
.link.dimmed { stroke-opacity: 0.03; }

.highlighted circle { filter: brightness(1.4) drop-shadow(0 0 6px var(--glow)); }
.highlighted text { fill: #f0f6fc; font-weight: 600; }
.link.highlighted { stroke-opacity: 0.8; stroke-width: 2; }

#detail-panel {
  position: fixed;
  top: 44px;
  right: -360px;
  width: 340px;
  height: calc(100vh - 44px);
  background: #161b22;
  border-left: 1px solid #30363d;
  z-index: 90;
  transition: right 0.25s ease;
  overflow-y: auto;
  padding: 20px;
}

#detail-panel.open { right: 0; }

#detail-panel .close-btn {
  position: absolute; top: 12px; right: 12px;
  background: none; border: none; color: #8b949e; cursor: pointer; font-size: 18px;
}
#detail-panel .close-btn:hover { color: #f0f6fc; }

#detail-panel h2 { font-size: 18px; color: #f0f6fc; margin-bottom: 4px; padding-right: 24px; }

#detail-panel .type-badge {
  display: inline-block; padding: 2px 8px; border-radius: 10px;
  font-size: 11px; font-weight: 600; margin-bottom: 12px;
}

#detail-panel .description { font-size: 13px; color: #8b949e; line-height: 1.5; margin-bottom: 16px; }

#detail-panel .section-title {
  font-size: 12px; font-weight: 600; color: #58a6ff;
  text-transform: uppercase; letter-spacing: 0.5px;
  margin-top: 16px; margin-bottom: 8px;
}

#detail-panel .child-list { list-style: none; padding: 0; }
#detail-panel .child-list li {
  font-size: 12px; color: #c9d1d9; padding: 3px 0 3px 8px; cursor: pointer;
}
#detail-panel .child-list li:hover { color: #58a6ff; }
#detail-panel .child-list a { color: #58a6ff; text-decoration: none; }
#detail-panel .child-list a:hover { text-decoration: underline; }
#detail-panel .child-type { font-size: 10px; color: #8b949e; margin-left: 4px; }

#detail-panel .meta-item { font-size: 12px; color: #8b949e; margin-bottom: 4px; }
#detail-panel .meta-item span { color: #c9d1d9; }

.legend {
  position: fixed; bottom: 12px; left: 192px;
  background: rgba(22, 27, 34, 0.9); border: 1px solid #30363d;
  border-radius: 8px; padding: 10px 14px; font-size: 11px; z-index: 80;
}
.legend-item { display: flex; align-items: center; gap: 6px; margin-bottom: 3px; }
.legend-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
</style>
</head>
<body>

<div id="toolbar">
  <span class="title">Interverse Ecosystem</span>
  <span class="stats" id="stats"></span>
  <input type="text" id="search-box" placeholder="Search nodes..." oninput="onSearch(this.value)">
</div>

<div id="filter-sidebar">
  <div class="sidebar-title">Filters</div>
  <div class="meta-row">
    <button class="filter-btn meta" onclick="showAll()">All</button>
    <button class="filter-btn meta" onclick="hideAll()">None</button>
  </div>
  <div id="filter-list"></div>
  <div class="sidebar-title" style="margin-top: 12px">Domains</div>
  <div class="meta-row">
    <button class="filter-btn meta" onclick="showAllDomains()">All</button>
    <button class="filter-btn meta" onclick="hideAllDomains()">None</button>
  </div>
  <div id="domain-list"></div>
</div>

<div id="graph"></div>

<div id="detail-panel">
  <button class="close-btn" onclick="closePanel()">&times;</button>
  <div id="panel-content"></div>
</div>

<div class="legend" id="legend"></div>

<script>
// DATA_PLACEHOLDER is replaced by the generator with scanned JSON
const data = /*DATA_PLACEHOLDER*/;

const TYPE_COLORS = {
  'plugin': '#4A90D9', 'skill': '#50C878', 'agent': '#FF8C42',
  'mcp-server': '#9B59B6', 'hook-event': '#E74C3C', 'hub': '#F39C12',
  'kernel': '#1ABC9C', 'service': '#E74C3C', 'sdk': '#95A5A6',
  'tui': '#E91E63', 'monorepo': '#58a6ff'
};

const TYPE_SIZES = {
  'monorepo': 24, 'hub': 20, 'kernel': 16, 'service': 14, 'tui': 14,
  'sdk': 12, 'plugin': 12, 'skill': 6, 'agent': 6, 'mcp-server': 7, 'hook-event': 7
};

const TYPE_LABELS = {
  'plugin': 'Plugin', 'skill': 'Skill', 'agent': 'Agent', 'mcp-server': 'MCP Server',
  'hook-event': 'Hook Event', 'hub': 'Hub', 'kernel': 'Kernel', 'service': 'Service',
  'sdk': 'SDK', 'tui': 'TUI', 'monorepo': 'Monorepo'
};

// State
const activeFilters = new Set(Object.keys(TYPE_COLORS));
let selectedNode = null;
let searchQuery = '';

// Stats
document.getElementById('stats').textContent =
  data.stats.nodes + ' nodes \u00b7 ' + data.stats.edges + ' edges \u00b7 ' + domainNames.length + ' domains \u00b7 Generated ' + new Date(data.generated).toLocaleDateString();

// Build filter buttons into sidebar
const filterList = document.getElementById('filter-list');
for (const [type, color] of Object.entries(TYPE_COLORS)) {
  const count = data.stats.byType[type] || 0;
  if (count === 0) continue;
  const btn = document.createElement('button');
  btn.className = 'filter-btn active';
  btn.style.setProperty('--type-color', color);
  const dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  btn.appendChild(document.createTextNode(TYPE_LABELS[type] + ' (' + count + ')'));
  btn.dataset.type = type;
  btn.onclick = function() { toggleFilter(type, btn); };
  filterList.appendChild(btn);
}

// Build legend
const legend = document.getElementById('legend');
for (const [type, color] of Object.entries(TYPE_COLORS)) {
  if (!(data.stats.byType[type] > 0)) continue;
  const item = document.createElement('div');
  item.className = 'legend-item';
  const dot = document.createElement('div');
  dot.className = 'legend-dot';
  dot.style.background = color;
  item.appendChild(dot);
  item.appendChild(document.createTextNode(TYPE_LABELS[type]));
  legend.appendChild(item);
}

// Build domain toggle buttons
var domainList = document.getElementById('domain-list');
domainNames.forEach(function(domain) {
  var btn = document.createElement('button');
  btn.className = 'filter-btn active';
  var color = DOMAIN_COLORS[domain];
  btn.style.setProperty('--type-color', color);
  var dot = document.createElement('span');
  dot.className = 'dot';
  dot.style.background = color;
  btn.appendChild(dot);
  var count = domainMembers[domain].size;
  btn.appendChild(document.createTextNode(DOMAIN_LABELS[domain] + ' (' + count + ')'));
  btn.dataset.domain = domain;
  btn.onclick = function() { toggleDomain(domain, btn); };
  domainList.appendChild(btn);
});

// D3 Setup
const sidebarWidth = 180;
const width = window.innerWidth;
const height = window.innerHeight - 44;

const svg = d3.select('#graph').append('svg').attr('width', width).attr('height', height);
const g = svg.append('g');

// Hull layer (drawn first = behind everything)
const hullGroup = g.append('g').attr('class', 'hulls');
const hullLabelGroup = g.append('g').attr('class', 'hull-labels');

const zoomBehavior = d3.zoom()
  .scaleExtent([0.1, 4])
  .on('zoom', function(event) { g.attr('transform', event.transform); });

svg.call(zoomBehavior);

// Graph data
const graphNodes = data.nodes.map(function(n) { return Object.assign({}, n); });
const graphLinks = data.edges.filter(function(e) { return e.type !== 'overlaps-with'; })
  .map(function(e) { return Object.assign({}, e); });

// Build domain groups from overlap edges
const domainMembers = {};  // domain -> Set of node IDs
data.edges.forEach(function(e) {
  if (e.type !== 'overlaps-with' || !e.meta || !e.meta.domains) return;
  e.meta.domains.forEach(function(domain) {
    if (!domainMembers[domain]) domainMembers[domain] = new Set();
    domainMembers[domain].add(e.source);
    domainMembers[domain].add(e.target);
  });
});

const DOMAIN_COLORS = {};
const DOMAIN_PALETTE = [
  '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
  '#DDA0DD', '#FF8C42', '#98D8C8', '#F7DC6F', '#BB8FCE',
  '#85C1E9'
];
var domainNames = Object.keys(domainMembers).sort();
domainNames.forEach(function(name, i) {
  DOMAIN_COLORS[name] = DOMAIN_PALETTE[i % DOMAIN_PALETTE.length];
});

const DOMAIN_LABELS = {};
domainNames.forEach(function(name) {
  DOMAIN_LABELS[name] = name.replace(/-/g, ' ').replace(/\b\w/g, function(c) { return c.toUpperCase(); });
});

const activeDomains = new Set(domainNames);

// Force simulation
const simulation = d3.forceSimulation(graphNodes)
  .force('link', d3.forceLink(graphLinks).id(function(d) { return d.id; }).distance(function(d) {
    if (d.type === 'part-of') return 100;
    if (d.type === 'companion-of') return 120;
    if (d.type === 'overlaps-with') return 90;
    if (d.type === 'provides-skill' || d.type === 'provides-agent') return 50;
    return 80;
  }))
  .force('charge', d3.forceManyBody().strength(function(d) {
    if (d.type === 'monorepo' || d.type === 'hub') return -400;
    if (d.type === 'plugin' || d.type === 'kernel') return -200;
    return -60;
  }))
  .force('center', d3.forceCenter((width - sidebarWidth) / 2 + sidebarWidth, height / 2))
  .force('collision', d3.forceCollide().radius(function(d) { return (TYPE_SIZES[d.type] || 8) + 4; }));

// Draw links
const link = g.append('g').selectAll('line').data(graphLinks).join('line')
  .attr('class', function(d) { return 'link ' + d.type; })
  .attr('stroke-width', function(d) { return d.type === 'companion-of' ? 2 : 1; });

// Draw nodes
const node = g.append('g').selectAll('g').data(graphNodes).join('g')
  .attr('class', 'node')
  .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

node.append('circle')
  .attr('r', function(d) { return TYPE_SIZES[d.type] || 8; })
  .attr('fill', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
  .style('--glow', function(d) { return TYPE_COLORS[d.type] || '#8b949e'; })
  .on('click', function(event, d) { event.stopPropagation(); selectNode(d); });

node.append('text')
  .attr('dx', function(d) { return (TYPE_SIZES[d.type] || 8) + 4; })
  .attr('dy', 3)
  .text(function(d) { return d.label; })
  .style('font-size', function(d) {
    if (d.type === 'monorepo' || d.type === 'hub') return '13px';
    if (d.type === 'plugin' || d.type === 'kernel' || d.type === 'service') return '11px';
    return '9px';
  });

svg.on('click', function() { deselectAll(); closePanel(); });

// Convex hull helper — takes [[x,y], ...], returns expanded hull path string
function computeHullPath(points, padding) {
  if (points.length < 2) return null;
  if (points.length === 2) {
    // Two-point "hull": draw a rounded rect between them
    var dx = points[1][0] - points[0][0];
    var dy = points[1][1] - points[0][1];
    var len = Math.sqrt(dx * dx + dy * dy) || 1;
    var nx = -dy / len * padding;
    var ny = dx / len * padding;
    return 'M' + (points[0][0] + nx) + ',' + (points[0][1] + ny) +
      'L' + (points[1][0] + nx) + ',' + (points[1][1] + ny) +
      'A' + padding + ',' + padding + ' 0 0,1 ' + (points[1][0] - nx) + ',' + (points[1][1] - ny) +
      'L' + (points[0][0] - nx) + ',' + (points[0][1] - ny) +
      'A' + padding + ',' + padding + ' 0 0,1 ' + (points[0][0] + nx) + ',' + (points[0][1] + ny) +
      'Z';
  }
  var hull = d3.polygonHull(points);
  if (!hull) return null;
  // Expand hull outward by padding
  var cx = d3.mean(hull, function(p) { return p[0]; });
  var cy = d3.mean(hull, function(p) { return p[1]; });
  var expanded = hull.map(function(p) {
    var dx = p[0] - cx;
    var dy = p[1] - cy;
    var dist = Math.sqrt(dx * dx + dy * dy) || 1;
    return [p[0] + dx / dist * padding, p[1] + dy / dist * padding];
  });
  return 'M' + expanded.map(function(p) { return p[0] + ',' + p[1]; }).join('L') + 'Z';
}

// Build node lookup for fast access
var nodeById = {};
graphNodes.forEach(function(n) { nodeById[n.id] = n; });

function updateHulls() {
  var hullData = [];
  domainNames.forEach(function(domain) {
    if (!activeDomains.has(domain)) return;
    var points = [];
    domainMembers[domain].forEach(function(id) {
      var n = nodeById[id];
      if (n && activeFilters.has(n.type)) points.push([n.x, n.y]);
    });
    if (points.length >= 2) {
      hullData.push({ domain: domain, points: points, color: DOMAIN_COLORS[domain] });
    }
  });

  var hulls = hullGroup.selectAll('path').data(hullData, function(d) { return d.domain; });
  hulls.exit().remove();
  hulls.enter().append('path')
    .attr('class', 'domain-hull')
    .merge(hulls)
    .attr('fill', function(d) { return d.color; })
    .attr('stroke', function(d) { return d.color; })
    .attr('d', function(d) { return computeHullPath(d.points, 30); });

  var labels = hullLabelGroup.selectAll('text').data(hullData, function(d) { return d.domain; });
  labels.exit().remove();
  labels.enter().append('text')
    .attr('class', 'domain-label')
    .merge(labels)
    .attr('fill', function(d) { return d.color; })
    .attr('x', function(d) { return d3.mean(d.points, function(p) { return p[0]; }); })
    .attr('y', function(d) { return d3.min(d.points, function(p) { return p[1]; }) - 35; })
    .text(function(d) { return DOMAIN_LABELS[d.domain]; });
}

simulation.on('tick', function() {
  link.attr('x1', function(d) { return d.source.x; })
    .attr('y1', function(d) { return d.source.y; })
    .attr('x2', function(d) { return d.target.x; })
    .attr('y2', function(d) { return d.target.y; });
  node.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
  updateHulls();
});

// --- Interaction ---

function getNodeId(n) { return typeof n === 'object' ? n.id : n; }

function selectNode(d) {
  selectedNode = d;
  var connectedIds = new Set([d.id]);
  graphLinks.forEach(function(l) {
    if (getNodeId(l.source) === d.id) connectedIds.add(getNodeId(l.target));
    if (getNodeId(l.target) === d.id) connectedIds.add(getNodeId(l.source));
  });

  node.classed('highlighted', function(n) { return connectedIds.has(n.id); });
  node.classed('dimmed', function(n) { return !connectedIds.has(n.id); });
  link.classed('highlighted', function(l) { return getNodeId(l.source) === d.id || getNodeId(l.target) === d.id; });
  link.classed('dimmed', function(l) { return getNodeId(l.source) !== d.id && getNodeId(l.target) !== d.id; });

  showDetailPanel(d);
}

function deselectAll() {
  selectedNode = null;
  node.classed('highlighted', false).classed('dimmed', false);
  link.classed('highlighted', false).classed('dimmed', false);
}

function showDetailPanel(d) {
  var panel = document.getElementById('detail-panel');
  var content = document.getElementById('panel-content');
  var color = TYPE_COLORS[d.type] || '#8b949e';

  // Find children and parents
  var children = [], parents = [];
  graphLinks.forEach(function(l) {
    var sid = getNodeId(l.source), tid = getNodeId(l.target);

    if (l.type === 'part-of') return;

    // Overlap is symmetric; show in one "Overlaps" section regardless of edge direction.
    if (l.type === 'overlaps-with') {
      if (sid === d.id || tid === d.id) {
        var otherId = sid === d.id ? tid : sid;
        var otherNode = graphNodes.find(function(n) { return n.id === otherId; });
        if (otherNode) children.push(Object.assign({ edgeType: l.type, edgeMeta: l.meta || {} }, otherNode));
      }
      return;
    }

    if (sid === d.id) {
      var tn = graphNodes.find(function(n) { return n.id === tid; });
      if (tn) children.push(Object.assign({ edgeType: l.type, edgeMeta: l.meta || {} }, tn));
    }
    if (tid === d.id) {
      var sn = graphNodes.find(function(n) { return n.id === sid; });
      if (sn) parents.push(Object.assign({ edgeType: l.type, edgeMeta: l.meta || {} }, sn));
    }
  });

  // Build panel content using DOM methods (safe against injection)
  while (content.firstChild) content.removeChild(content.firstChild);

  var h2 = document.createElement('h2');
  h2.textContent = d.label;
  content.appendChild(h2);

  var badge = document.createElement('div');
  badge.className = 'type-badge';
  badge.style.cssText = 'background:' + color + '22;color:' + color + ';border:1px solid ' + color;
  badge.textContent = TYPE_LABELS[d.type];
  content.appendChild(badge);

  if (d.description) {
    var desc = document.createElement('div');
    desc.className = 'description';
    desc.textContent = d.description;
    content.appendChild(desc);
  }

  // Meta
  if (d.meta) {
    var metaFields = [
      ['Version', d.meta.version], ['Path', d.meta.path],
      ['Commands', d.meta.commandCount], ['Plugin', d.meta.plugin]
    ];
    metaFields.forEach(function(pair) {
      if (!pair[1]) return;
      var mi = document.createElement('div');
      mi.className = 'meta-item';
      mi.textContent = pair[0] + ': ';
      var sp = document.createElement('span');
      sp.textContent = pair[1];
      mi.appendChild(sp);
      content.appendChild(mi);
    });
  }

  // External links
  var links = [];
  if (d.meta && d.meta.repoUrl) {
    links.push({ label: 'GitHub repo', url: d.meta.repoUrl });
  }
  if (d.type === 'hook-event' && d.meta && d.meta.docsUrl) {
    links.push({ label: 'Claude Code hooks docs', url: d.meta.docsUrl });
  }
  if (links.length > 0) {
    var linksTitle = document.createElement('div');
    linksTitle.className = 'section-title';
    linksTitle.textContent = 'Links';
    content.appendChild(linksTitle);

    var linksList = document.createElement('ul');
    linksList.className = 'child-list';
    links.forEach(function(item) {
      var li = document.createElement('li');
      li.style.borderLeft = '2px solid ' + color;
      li.style.cursor = 'default';
      var a = document.createElement('a');
      a.href = item.url;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      a.textContent = item.label;
      a.onclick = function(event) { event.stopPropagation(); };
      li.appendChild(a);
      linksList.appendChild(li);
    });
    content.appendChild(linksList);
  }

  // Children grouped by edge type
  if (children.length > 0) {
    var grouped = {};
    children.forEach(function(c) {
      if (!grouped[c.edgeType]) grouped[c.edgeType] = [];
      grouped[c.edgeType].push(c);
    });

    var sectionLabels = {
      'provides-skill': 'Skills', 'provides-agent': 'Agents', 'provides-mcp': 'MCP Servers',
      'fires-hook': 'Hook Events', 'companion-of': 'Companions', 'depends-on': 'Dependencies',
      'overlaps-with': 'Overlaps'
    };

    Object.keys(grouped).forEach(function(edgeType) {
      var title = document.createElement('div');
      title.className = 'section-title';
      title.textContent = sectionLabels[edgeType] || edgeType;
      content.appendChild(title);

      var ul = document.createElement('ul');
      ul.className = 'child-list';
      grouped[edgeType].forEach(function(item) {
        var li = document.createElement('li');
        li.style.borderLeft = '2px solid ' + (TYPE_COLORS[item.type] || '#8b949e');
        li.textContent = item.label + ' ';
        var typeSpan = document.createElement('span');
        typeSpan.className = 'child-type';
        if (item.edgeType === 'overlaps-with') {
          var overlapScore = item.edgeMeta && typeof item.edgeMeta.score === 'number'
            ? item.edgeMeta.score.toFixed(2)
            : 'n/a';
          var overlapDomains = item.edgeMeta && Array.isArray(item.edgeMeta.domains) && item.edgeMeta.domains.length > 0
            ? ' [' + item.edgeMeta.domains.join(', ') + ']'
            : '';
          typeSpan.textContent = TYPE_LABELS[item.type] + ' · score ' + overlapScore + overlapDomains;
        } else {
          typeSpan.textContent = TYPE_LABELS[item.type];
        }
        li.appendChild(typeSpan);
        li.onclick = function() { navigateTo(item.id); };
        ul.appendChild(li);
      });
      content.appendChild(ul);
    });
  }

  // Parents
  if (parents.length > 0) {
    var pTitle = document.createElement('div');
    pTitle.className = 'section-title';
    pTitle.textContent = 'Provided by';
    content.appendChild(pTitle);

    var pUl = document.createElement('ul');
    pUl.className = 'child-list';
    parents.forEach(function(p) {
      var li = document.createElement('li');
      li.style.borderLeft = '2px solid ' + (TYPE_COLORS[p.type] || '#8b949e');
      li.textContent = p.label + ' ';
      var ts = document.createElement('span');
      ts.className = 'child-type';
      ts.textContent = TYPE_LABELS[p.type];
      li.appendChild(ts);
      li.onclick = function() { navigateTo(p.id); };
      pUl.appendChild(li);
    });
    content.appendChild(pUl);
  }

  panel.classList.add('open');
}

function closePanel() { document.getElementById('detail-panel').classList.remove('open'); }

function navigateTo(nodeId) {
  var targetNode = graphNodes.find(function(n) { return n.id === nodeId; });
  if (targetNode) {
    selectNode(targetNode);
    var transform = d3.zoomTransform(svg.node());
    var x = width / 2 - targetNode.x * transform.k;
    var y = height / 2 - targetNode.y * transform.k;
    svg.transition().duration(500).call(
      zoomBehavior.transform,
      d3.zoomIdentity.translate(x, y).scale(transform.k)
    );
  }
}

// Filters
function toggleFilter(type, btn) {
  if (activeFilters.has(type)) { activeFilters.delete(type); btn.classList.remove('active'); }
  else { activeFilters.add(type); btn.classList.add('active'); }
  applyFilters();
}

function showAll() {
  Object.keys(TYPE_COLORS).forEach(function(t) { activeFilters.add(t); });
  document.querySelectorAll('.filter-btn[data-type]').forEach(function(b) { b.classList.add('active'); });
  applyFilters();
}

function hideAll() {
  activeFilters.clear();
  document.querySelectorAll('.filter-btn[data-type]').forEach(function(b) { b.classList.remove('active'); });
  applyFilters();
}

function toggleDomain(domain, btn) {
  if (activeDomains.has(domain)) { activeDomains.delete(domain); btn.classList.remove('active'); }
  else { activeDomains.add(domain); btn.classList.add('active'); }
  updateHulls();
}

function showAllDomains() {
  domainNames.forEach(function(d) { activeDomains.add(d); });
  document.querySelectorAll('.filter-btn[data-domain]').forEach(function(b) { b.classList.add('active'); });
  updateHulls();
}

function hideAllDomains() {
  activeDomains.clear();
  document.querySelectorAll('.filter-btn[data-domain]').forEach(function(b) { b.classList.remove('active'); });
  updateHulls();
}

function applyFilters() {
  node.style('display', function(d) {
    if (!activeFilters.has(d.type)) return 'none';
    if (searchQuery && !d.label.toLowerCase().includes(searchQuery) && !d.id.toLowerCase().includes(searchQuery)) return 'none';
    return null;
  });
  link.style('display', function(l) {
    var sn = graphNodes.find(function(n) { return n.id === getNodeId(l.source); });
    var tn = graphNodes.find(function(n) { return n.id === getNodeId(l.target); });
    if (!sn || !tn || !activeFilters.has(sn.type) || !activeFilters.has(tn.type)) return 'none';
    return null;
  });
  updateHulls();
}

function onSearch(query) {
  searchQuery = query.toLowerCase().trim();
  applyFilters();
  if (searchQuery) {
    node.classed('highlighted', function(d) {
      return d.label.toLowerCase().includes(searchQuery) || d.id.toLowerCase().includes(searchQuery);
    });
    node.classed('dimmed', function(d) {
      return !(d.label.toLowerCase().includes(searchQuery) || d.id.toLowerCase().includes(searchQuery));
    });
  } else { deselectAll(); }
}

// Drag
function dragstarted(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x; d.fy = d.y;
}
function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
function dragended(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  d.fx = null; d.fy = null;
}

// Zoom to fit after layout settles
setTimeout(function() {
  var bounds = g.node().getBBox();
  var graphWidth = width - sidebarWidth;
  var scale = 0.8 / Math.max(bounds.width / graphWidth, bounds.height / height);
  var midX = bounds.x + bounds.width / 2;
  var midY = bounds.y + bounds.height / 2;
  svg.transition().duration(750).call(
    zoomBehavior.transform,
    d3.zoomIdentity.translate(graphWidth / 2 + sidebarWidth - scale * midX, height / 2 - scale * midY).scale(scale)
  );
}, 2000);
</script>
</body>
</html>
